{"0": {"parameters": {"seq_len": 6, "seq_rep": 3, "surv_state": "11", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Z\nz q1[4];\nz q1[5];\nz q1[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "1": {"parameters": {"seq_len": 6, "seq_rep": 2, "surv_state": "01", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nbarrier q0;\nbarrier q1;\n\n//Logical Z\nz q1[4];\nz q1[5];\nz q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\nrz(pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "2": {"parameters": {"seq_len": 6, "seq_rep": 6, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n//Logical Z\nz q1[4];\nz q1[5];\nz q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "3": {"parameters": {"seq_len": 14, "seq_rep": 0, "surv_state": "10", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "4": {"parameters": {"seq_len": 6, "seq_rep": 5, "surv_state": "01", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nrz(-pi/2) q1;\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q1;\nrz(pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "5": {"parameters": {"seq_len": 2, "seq_rep": 5, "surv_state": "11", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "6": {"parameters": {"seq_len": 6, "seq_rep": 7, "surv_state": "01", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "7": {"parameters": {"seq_len": 10, "seq_rep": 1, "surv_state": "10", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "8": {"parameters": {"seq_len": 6, "seq_rep": 1, "surv_state": "11", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "9": {"parameters": {"seq_len": 14, "seq_rep": 4, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Z\nz q1[4];\nz q1[5];\nz q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q1;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Z\nz q1[4];\nz q1[5];\nz q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "10": {"parameters": {"seq_len": 10, "seq_rep": 8, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nrz(pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Z\nz q1[4];\nz q1[5];\nz q1[6];\n\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "11": {"parameters": {"seq_len": 2, "seq_rep": 6, "surv_state": "11", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "12": {"parameters": {"seq_len": 14, "seq_rep": 9, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nrz(pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "13": {"parameters": {"seq_len": 6, "seq_rep": 4, "surv_state": "11", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "14": {"parameters": {"seq_len": 14, "seq_rep": 1, "surv_state": "11", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "15": {"parameters": {"seq_len": 2, "seq_rep": 7, "surv_state": "11", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "16": {"parameters": {"seq_len": 10, "seq_rep": 0, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n// Logical H\nh q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Z\nz q1[4];\nz q1[5];\nz q1[6];\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n//Logical Z\nz q1[4];\nz q1[5];\nz q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "17": {"parameters": {"seq_len": 6, "seq_rep": 0, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n// Logical H\nh q0;\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "18": {"parameters": {"seq_len": 14, "seq_rep": 2, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "19": {"parameters": {"seq_len": 14, "seq_rep": 7, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n// Logical H\nh q1;\n\n//Logical Z\nz q1[4];\nz q1[5];\nz q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "20": {"parameters": {"seq_len": 10, "seq_rep": 3, "surv_state": "11", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nrz(pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Z\nz q1[4];\nz q1[5];\nz q1[6];\n\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "21": {"parameters": {"seq_len": 6, "seq_rep": 9, "surv_state": "01", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "22": {"parameters": {"seq_len": 10, "seq_rep": 2, "surv_state": "11", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nrz(-pi/2) q1;\n// Logical H\nh q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Logical H\nh q0;\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "23": {"parameters": {"seq_len": 10, "seq_rep": 7, "surv_state": "11", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Logical H\nh q0;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n//Logical Z\nz q1[4];\nz q1[5];\nz q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "24": {"parameters": {"seq_len": 2, "seq_rep": 8, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "25": {"parameters": {"seq_len": 2, "seq_rep": 0, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "26": {"parameters": {"seq_len": 2, "seq_rep": 9, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nrz(-pi/2) q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "27": {"parameters": {"seq_len": 14, "seq_rep": 3, "surv_state": "10", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "28": {"parameters": {"seq_len": 10, "seq_rep": 4, "surv_state": "11", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(pi/2) q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Z\nz q1[4];\nz q1[5];\nz q1[6];\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "29": {"parameters": {"seq_len": 14, "seq_rep": 6, "surv_state": "10", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Logical H\nh q0;\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "30": {"parameters": {"seq_len": 2, "seq_rep": 1, "surv_state": "11", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "31": {"parameters": {"seq_len": 10, "seq_rep": 9, "surv_state": "01", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q1;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "32": {"parameters": {"seq_len": 2, "seq_rep": 3, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "33": {"parameters": {"seq_len": 2, "seq_rep": 2, "surv_state": "11", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Logical H\nh q0;\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "34": {"parameters": {"seq_len": 2, "seq_rep": 4, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "35": {"parameters": {"seq_len": 10, "seq_rep": 5, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "36": {"parameters": {"seq_len": 6, "seq_rep": 8, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n// Logical H\nh q0;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "37": {"parameters": {"seq_len": 14, "seq_rep": 8, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q1;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Z\nz q1[4];\nz q1[5];\nz q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "38": {"parameters": {"seq_len": 10, "seq_rep": 6, "surv_state": "11", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q1;\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(pi/2) q1;\n// Logical H\nh q0;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}, "39": {"parameters": {"seq_len": 14, "seq_rep": 5, "surv_state": "00", "QEC": "False"}, "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg a0[3];\nqreg a1[3];\ncreg init[2];\ncreg flag_x0[3];\ncreg flag_z0[3];\ncreg flags0[3];\ncreg flag_x1[3];\ncreg flag_z1[3];\ncreg flags1[3];\ncreg syn_x0[3];\ncreg syn_z0[3];\ncreg syn_x1[3];\ncreg syn_z1[3];\ncreg syndromes0[3];\ncreg syndromes1[3];\ncreg scratch0[7];\ncreg scratch1[7];\ncreg c0[7];\ncreg c1[7];\ncreg c[2];\ncreg pf0[2];\ncreg pf1[2];\ncreg last_raw_syn_x0[3];\ncreg last_raw_syn_z0[3];\ncreg last_raw_syn_x1[3];\ncreg last_raw_syn_z1[3];\ncreg log_raw0[1];\ncreg log0[1];\ncreg log_raw1[1];\ncreg log1[1];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nreset q0;\nreset a0[0];\nbarrier q0, a0[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier a0[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],a0[0];\ncx q0[1],a0[0];\ncx q0[3],a0[0];\nmeasure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],a0[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset a0[0];\nif(init[0] == 1) barrier q0, a0[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier a0[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],a0[0];\nif(init[0] == 1) cx q0[1],a0[0];\nif(init[0] == 1) cx q0[3],a0[0];\nif(init[0] == 1) measure a0[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nreset q1;\nreset a1[0];\nbarrier q1, a1[0];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier a1[0],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],a1[0];\ncx q1[1],a1[0];\ncx q1[3],a1[0];\nmeasure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],a1[0];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset a1[0];\nif(init[1] == 1) barrier q1, a1[0];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier a1[0],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],a1[0];\nif(init[1] == 1) cx q1[1],a1[0];\nif(init[1] == 1) cx q1[3],a1[0];\nif(init[1] == 1) measure a1[0] -> init[1];\n\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n//Logical Z\nz q1[4];\nz q1[5];\nz q1[6];\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nbarrier q0;\nbarrier q1;\nrz(-pi/2) q1;\n// Logical H\nh q1;\n// Logical H\nh q0;\nrz(pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\n// Logical H\nh q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n\n//Logical Z\nz q1[4];\nz q1[5];\nz q1[6];\n\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q0;\nrz(-pi/2) q0;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q0;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\nrz(pi/2) q1;\nbarrier q0;\nbarrier q1;\nrz(pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical Y\ny q0[4];\ny q0[5];\ny q0[6];\n\nbarrier q0;\nbarrier q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n// Logical H\nh q0;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Logical H\nh q1;\n\n//Logical Y\ny q1[4];\ny q1[5];\ny q1[6];\n\n// Logical H\nh q0;\nbarrier q0;\nbarrier q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nlog_raw0 = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z0;\n\n// Correct logical output based on measured out syndromes\nlog0 = log_raw0;\nif(syn_meas0 == 2) log0 = log0 ^ 1;\nif(syn_meas0 == 4) log0 = log0 ^ 1;\nif(syn_meas0 == 6) log0 = log0 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog0 = log0 ^ pf0[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nlog_raw1 = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z1;\n\n// Correct logical output based on measured out syndromes\nlog1 = log_raw1;\nif(syn_meas1 == 2) log1 = log1 ^ 1;\nif(syn_meas1 == 4) log1 = log1 ^ 1;\nif(syn_meas1 == 6) log1 = log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nlog1 = log1 ^ pf1[0];\nc[0] = log0[0];\nc[1] = log1[0];"}}