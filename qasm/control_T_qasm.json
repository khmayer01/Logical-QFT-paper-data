{"0": {"parameters": "0+", "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg c[2];\ncreg c0[7];\ncreg c0_log_raw[1];\ncreg syn_meas0[3];\ncreg c0_log[1];\ncreg c1[7];\ncreg c1_log_raw[1];\ncreg syn_meas1[3];\ncreg c1_log[1];\ncreg c2[7];\ncreg c2_log_raw[1];\ncreg syn_meas2[3];\ncreg c2_log[1];\ncreg init[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\ncreg cT1[7];\ncreg cT1_log_raw[1];\ncreg syn_measT1[3];\ncreg cT_log[1];\ncreg cT2[7];\ncreg cT2_log_raw[1];\ncreg syn_measT2[3];\ncreg cT2_log[1];\ncreg cT3[7];\ncreg cT3_log_raw[1];\ncreg syn_measT3[3];\ncreg cT3_log[1];\ncreg cT4[7];\ncreg cT4_log_raw[1];\ncreg syn_measT4[3];\ncreg cT4_log[1];\ncreg cT5[7];\ncreg cT5_log_raw[1];\ncreg syn_measT5[3];\ncreg cT5_log[1];\ncreg cT6[7];\ncreg cT6_log_raw[1];\ncreg syn_measT6[3];\ncreg cT6_log[1];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n// Logical H\nh q1;\n// Logical H\nh q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT1[0];\nmeasure q2[1] -> cT1[1];\nmeasure q2[2] -> cT1[2];\nmeasure q2[3] -> cT1[3];\nmeasure q2[4] -> cT1[4];\nmeasure q2[5] -> cT1[5];\nmeasure q2[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log = cT1_log_raw;\nif(syn_measT1 == 2) cT_log = cT_log ^ 1;\nif(syn_measT1 == 4) cT_log = cT_log ^ 1;\nif(syn_measT1 == 6) cT_log = cT_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log = cT_log ^ pf[0];\n\n//Logical X\nif(cT_log[0] == 1) x q3[4];\nif(cT_log[0] == 1) x q3[5];\nif(cT_log[0] == 1) x q3[6];\n\nif(cT_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q2[4];\nif(cT2_log[0] == 1) x q2[5];\nif(cT2_log[0] == 1) x q2[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q0, q2;\ncx q0[0], q2[0];\ncx q0[1], q2[1];\ncx q0[2], q2[2];\ncx q0[3], q2[3];\ncx q0[4], q2[4];\ncx q0[5], q2[5];\ncx q0[6], q2[6];\nbarrier q0, q2;\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT3[0];\nmeasure q2[1] -> cT3[1];\nmeasure q2[2] -> cT3[2];\nmeasure q2[3] -> cT3[3];\nmeasure q2[4] -> cT3[4];\nmeasure q2[5] -> cT3[5];\nmeasure q2[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q2[4];\nif(cT4_log[0] == 1) x q2[5];\nif(cT4_log[0] == 1) x q2[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q2;\n// Logical H\nh q2;\nrz(-pi/2) q2;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT5[0];\nmeasure q2[1] -> cT5[1];\nmeasure q2[2] -> cT5[2];\nmeasure q2[3] -> cT5[3];\nmeasure q2[4] -> cT5[4];\nmeasure q2[5] -> cT5[5];\nmeasure q2[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c2[0];\nmeasure q3[1] -> c2[1];\nmeasure q3[2] -> c2[2];\nmeasure q3[3] -> c2[3];\nmeasure q3[4] -> c2[4];\nmeasure q3[5] -> c2[5];\nmeasure q3[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\n// Logical H\nif(c2_log[0] == 1) h q1;\n\n// Transversal Logical CX\nif(c2_log[0] == 1) barrier q0, q1;\nif(c2_log[0] == 1) cx q0[0], q1[0];\nif(c2_log[0] == 1) cx q0[1], q1[1];\nif(c2_log[0] == 1) cx q0[2], q1[2];\nif(c2_log[0] == 1) cx q0[3], q1[3];\nif(c2_log[0] == 1) cx q0[4], q1[4];\nif(c2_log[0] == 1) cx q0[5], q1[5];\nif(c2_log[0] == 1) cx q0[6], q1[6];\nif(c2_log[0] == 1) barrier q0, q1;\n\n// Logical H\nif(c2_log[0] == 1) h q1;\n// Logical H\nh q1;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];"}, "1": {"parameters": "0-", "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg c[2];\ncreg c0[7];\ncreg c0_log_raw[1];\ncreg syn_meas0[3];\ncreg c0_log[1];\ncreg c1[7];\ncreg c1_log_raw[1];\ncreg syn_meas1[3];\ncreg c1_log[1];\ncreg c2[7];\ncreg c2_log_raw[1];\ncreg syn_meas2[3];\ncreg c2_log[1];\ncreg init[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\ncreg cT1[7];\ncreg cT1_log_raw[1];\ncreg syn_measT1[3];\ncreg cT_log[1];\ncreg cT2[7];\ncreg cT2_log_raw[1];\ncreg syn_measT2[3];\ncreg cT2_log[1];\ncreg cT3[7];\ncreg cT3_log_raw[1];\ncreg syn_measT3[3];\ncreg cT3_log[1];\ncreg cT4[7];\ncreg cT4_log_raw[1];\ncreg syn_measT4[3];\ncreg cT4_log[1];\ncreg cT5[7];\ncreg cT5_log_raw[1];\ncreg syn_measT5[3];\ncreg cT5_log[1];\ncreg cT6[7];\ncreg cT6_log_raw[1];\ncreg syn_measT6[3];\ncreg cT6_log[1];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Logical H\nh q1;\n// Logical H\nh q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT1[0];\nmeasure q2[1] -> cT1[1];\nmeasure q2[2] -> cT1[2];\nmeasure q2[3] -> cT1[3];\nmeasure q2[4] -> cT1[4];\nmeasure q2[5] -> cT1[5];\nmeasure q2[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log = cT1_log_raw;\nif(syn_measT1 == 2) cT_log = cT_log ^ 1;\nif(syn_measT1 == 4) cT_log = cT_log ^ 1;\nif(syn_measT1 == 6) cT_log = cT_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log = cT_log ^ pf[0];\n\n//Logical X\nif(cT_log[0] == 1) x q3[4];\nif(cT_log[0] == 1) x q3[5];\nif(cT_log[0] == 1) x q3[6];\n\nif(cT_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q2[4];\nif(cT2_log[0] == 1) x q2[5];\nif(cT2_log[0] == 1) x q2[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q0, q2;\ncx q0[0], q2[0];\ncx q0[1], q2[1];\ncx q0[2], q2[2];\ncx q0[3], q2[3];\ncx q0[4], q2[4];\ncx q0[5], q2[5];\ncx q0[6], q2[6];\nbarrier q0, q2;\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT3[0];\nmeasure q2[1] -> cT3[1];\nmeasure q2[2] -> cT3[2];\nmeasure q2[3] -> cT3[3];\nmeasure q2[4] -> cT3[4];\nmeasure q2[5] -> cT3[5];\nmeasure q2[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q2[4];\nif(cT4_log[0] == 1) x q2[5];\nif(cT4_log[0] == 1) x q2[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q2;\n// Logical H\nh q2;\nrz(-pi/2) q2;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT5[0];\nmeasure q2[1] -> cT5[1];\nmeasure q2[2] -> cT5[2];\nmeasure q2[3] -> cT5[3];\nmeasure q2[4] -> cT5[4];\nmeasure q2[5] -> cT5[5];\nmeasure q2[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c2[0];\nmeasure q3[1] -> c2[1];\nmeasure q3[2] -> c2[2];\nmeasure q3[3] -> c2[3];\nmeasure q3[4] -> c2[4];\nmeasure q3[5] -> c2[5];\nmeasure q3[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\n// Logical H\nif(c2_log[0] == 1) h q1;\n\n// Transversal Logical CX\nif(c2_log[0] == 1) barrier q0, q1;\nif(c2_log[0] == 1) cx q0[0], q1[0];\nif(c2_log[0] == 1) cx q0[1], q1[1];\nif(c2_log[0] == 1) cx q0[2], q1[2];\nif(c2_log[0] == 1) cx q0[3], q1[3];\nif(c2_log[0] == 1) cx q0[4], q1[4];\nif(c2_log[0] == 1) cx q0[5], q1[5];\nif(c2_log[0] == 1) cx q0[6], q1[6];\nif(c2_log[0] == 1) barrier q0, q1;\n\n// Logical H\nif(c2_log[0] == 1) h q1;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];"}, "2": {"parameters": "1+", "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg c[2];\ncreg c0[7];\ncreg c0_log_raw[1];\ncreg syn_meas0[3];\ncreg c0_log[1];\ncreg c1[7];\ncreg c1_log_raw[1];\ncreg syn_meas1[3];\ncreg c1_log[1];\ncreg c2[7];\ncreg c2_log_raw[1];\ncreg syn_meas2[3];\ncreg c2_log[1];\ncreg init[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\ncreg cT1[7];\ncreg cT1_log_raw[1];\ncreg syn_measT1[3];\ncreg cT_log[1];\ncreg cT2[7];\ncreg cT2_log_raw[1];\ncreg syn_measT2[3];\ncreg cT2_log[1];\ncreg cT3[7];\ncreg cT3_log_raw[1];\ncreg syn_measT3[3];\ncreg cT3_log[1];\ncreg cT4[7];\ncreg cT4_log_raw[1];\ncreg syn_measT4[3];\ncreg cT4_log[1];\ncreg cT5[7];\ncreg cT5_log_raw[1];\ncreg syn_measT5[3];\ncreg cT5_log[1];\ncreg cT6[7];\ncreg cT6_log_raw[1];\ncreg syn_measT6[3];\ncreg cT6_log[1];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Logical H\nh q1;\n// Logical H\nh q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT1[0];\nmeasure q2[1] -> cT1[1];\nmeasure q2[2] -> cT1[2];\nmeasure q2[3] -> cT1[3];\nmeasure q2[4] -> cT1[4];\nmeasure q2[5] -> cT1[5];\nmeasure q2[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log = cT1_log_raw;\nif(syn_measT1 == 2) cT_log = cT_log ^ 1;\nif(syn_measT1 == 4) cT_log = cT_log ^ 1;\nif(syn_measT1 == 6) cT_log = cT_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log = cT_log ^ pf[0];\n\n//Logical X\nif(cT_log[0] == 1) x q3[4];\nif(cT_log[0] == 1) x q3[5];\nif(cT_log[0] == 1) x q3[6];\n\nif(cT_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q2[4];\nif(cT2_log[0] == 1) x q2[5];\nif(cT2_log[0] == 1) x q2[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q0, q2;\ncx q0[0], q2[0];\ncx q0[1], q2[1];\ncx q0[2], q2[2];\ncx q0[3], q2[3];\ncx q0[4], q2[4];\ncx q0[5], q2[5];\ncx q0[6], q2[6];\nbarrier q0, q2;\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT3[0];\nmeasure q2[1] -> cT3[1];\nmeasure q2[2] -> cT3[2];\nmeasure q2[3] -> cT3[3];\nmeasure q2[4] -> cT3[4];\nmeasure q2[5] -> cT3[5];\nmeasure q2[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q2[4];\nif(cT4_log[0] == 1) x q2[5];\nif(cT4_log[0] == 1) x q2[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q2;\n// Logical H\nh q2;\nrz(-pi/2) q2;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT5[0];\nmeasure q2[1] -> cT5[1];\nmeasure q2[2] -> cT5[2];\nmeasure q2[3] -> cT5[3];\nmeasure q2[4] -> cT5[4];\nmeasure q2[5] -> cT5[5];\nmeasure q2[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c2[0];\nmeasure q3[1] -> c2[1];\nmeasure q3[2] -> c2[2];\nmeasure q3[3] -> c2[3];\nmeasure q3[4] -> c2[4];\nmeasure q3[5] -> c2[5];\nmeasure q3[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\n// Logical H\nif(c2_log[0] == 1) h q1;\n\n// Transversal Logical CX\nif(c2_log[0] == 1) barrier q0, q1;\nif(c2_log[0] == 1) cx q0[0], q1[0];\nif(c2_log[0] == 1) cx q0[1], q1[1];\nif(c2_log[0] == 1) cx q0[2], q1[2];\nif(c2_log[0] == 1) cx q0[3], q1[3];\nif(c2_log[0] == 1) cx q0[4], q1[4];\nif(c2_log[0] == 1) cx q0[5], q1[5];\nif(c2_log[0] == 1) cx q0[6], q1[6];\nif(c2_log[0] == 1) barrier q0, q1;\n\n// Logical H\nif(c2_log[0] == 1) h q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q2[4];\nif(cT6_log[0] == 1) x q2[5];\nif(cT6_log[0] == 1) x q2[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Logical H\nh q2;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> c1[0];\nmeasure q2[1] -> c1[1];\nmeasure q2[2] -> c1[2];\nmeasure q2[3] -> c1[3];\nmeasure q2[4] -> c1[4];\nmeasure q2[5] -> c1[5];\nmeasure q2[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];"}, "3": {"parameters": "1-", "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg c[2];\ncreg c0[7];\ncreg c0_log_raw[1];\ncreg syn_meas0[3];\ncreg c0_log[1];\ncreg c1[7];\ncreg c1_log_raw[1];\ncreg syn_meas1[3];\ncreg c1_log[1];\ncreg c2[7];\ncreg c2_log_raw[1];\ncreg syn_meas2[3];\ncreg c2_log[1];\ncreg init[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\ncreg cT1[7];\ncreg cT1_log_raw[1];\ncreg syn_measT1[3];\ncreg cT_log[1];\ncreg cT2[7];\ncreg cT2_log_raw[1];\ncreg syn_measT2[3];\ncreg cT2_log[1];\ncreg cT3[7];\ncreg cT3_log_raw[1];\ncreg syn_measT3[3];\ncreg cT3_log[1];\ncreg cT4[7];\ncreg cT4_log_raw[1];\ncreg syn_measT4[3];\ncreg cT4_log[1];\ncreg cT5[7];\ncreg cT5_log_raw[1];\ncreg syn_measT5[3];\ncreg cT5_log[1];\ncreg cT6[7];\ncreg cT6_log_raw[1];\ncreg syn_measT6[3];\ncreg cT6_log[1];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Logical H\nh q1;\n// Logical H\nh q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT1[0];\nmeasure q2[1] -> cT1[1];\nmeasure q2[2] -> cT1[2];\nmeasure q2[3] -> cT1[3];\nmeasure q2[4] -> cT1[4];\nmeasure q2[5] -> cT1[5];\nmeasure q2[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log = cT1_log_raw;\nif(syn_measT1 == 2) cT_log = cT_log ^ 1;\nif(syn_measT1 == 4) cT_log = cT_log ^ 1;\nif(syn_measT1 == 6) cT_log = cT_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log = cT_log ^ pf[0];\n\n//Logical X\nif(cT_log[0] == 1) x q3[4];\nif(cT_log[0] == 1) x q3[5];\nif(cT_log[0] == 1) x q3[6];\n\nif(cT_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q2[4];\nif(cT2_log[0] == 1) x q2[5];\nif(cT2_log[0] == 1) x q2[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q0, q2;\ncx q0[0], q2[0];\ncx q0[1], q2[1];\ncx q0[2], q2[2];\ncx q0[3], q2[3];\ncx q0[4], q2[4];\ncx q0[5], q2[5];\ncx q0[6], q2[6];\nbarrier q0, q2;\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT3[0];\nmeasure q2[1] -> cT3[1];\nmeasure q2[2] -> cT3[2];\nmeasure q2[3] -> cT3[3];\nmeasure q2[4] -> cT3[4];\nmeasure q2[5] -> cT3[5];\nmeasure q2[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q2[4];\nif(cT4_log[0] == 1) x q2[5];\nif(cT4_log[0] == 1) x q2[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q2;\n// Logical H\nh q2;\nrz(-pi/2) q2;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT5[0];\nmeasure q2[1] -> cT5[1];\nmeasure q2[2] -> cT5[2];\nmeasure q2[3] -> cT5[3];\nmeasure q2[4] -> cT5[4];\nmeasure q2[5] -> cT5[5];\nmeasure q2[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c2[0];\nmeasure q3[1] -> c2[1];\nmeasure q3[2] -> c2[2];\nmeasure q3[3] -> c2[3];\nmeasure q3[4] -> c2[4];\nmeasure q3[5] -> c2[5];\nmeasure q3[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\n// Logical H\nif(c2_log[0] == 1) h q1;\n\n// Transversal Logical CX\nif(c2_log[0] == 1) barrier q0, q1;\nif(c2_log[0] == 1) cx q0[0], q1[0];\nif(c2_log[0] == 1) cx q0[1], q1[1];\nif(c2_log[0] == 1) cx q0[2], q1[2];\nif(c2_log[0] == 1) cx q0[3], q1[3];\nif(c2_log[0] == 1) cx q0[4], q1[4];\nif(c2_log[0] == 1) cx q0[5], q1[5];\nif(c2_log[0] == 1) cx q0[6], q1[6];\nif(c2_log[0] == 1) barrier q0, q1;\n\n// Logical H\nif(c2_log[0] == 1) h q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q2[4];\nif(cT6_log[0] == 1) x q2[5];\nif(cT6_log[0] == 1) x q2[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Logical H\nh q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> c1[0];\nmeasure q2[1] -> c1[1];\nmeasure q2[2] -> c1[2];\nmeasure q2[3] -> c1[3];\nmeasure q2[4] -> c1[4];\nmeasure q2[5] -> c1[5];\nmeasure q2[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];"}, "4": {"parameters": "+0", "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg c[2];\ncreg c0[7];\ncreg c0_log_raw[1];\ncreg syn_meas0[3];\ncreg c0_log[1];\ncreg c1[7];\ncreg c1_log_raw[1];\ncreg syn_meas1[3];\ncreg c1_log[1];\ncreg c2[7];\ncreg c2_log_raw[1];\ncreg syn_meas2[3];\ncreg c2_log[1];\ncreg init[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\ncreg cT1[7];\ncreg cT1_log_raw[1];\ncreg syn_measT1[3];\ncreg cT_log[1];\ncreg cT2[7];\ncreg cT2_log_raw[1];\ncreg syn_measT2[3];\ncreg cT2_log[1];\ncreg cT3[7];\ncreg cT3_log_raw[1];\ncreg syn_measT3[3];\ncreg cT3_log[1];\ncreg cT4[7];\ncreg cT4_log_raw[1];\ncreg syn_measT4[3];\ncreg cT4_log[1];\ncreg cT5[7];\ncreg cT5_log_raw[1];\ncreg syn_measT5[3];\ncreg cT5_log[1];\ncreg cT6[7];\ncreg cT6_log_raw[1];\ncreg syn_measT6[3];\ncreg cT6_log[1];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n// Logical H\nh q0;\n// Logical H\nh q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT1[0];\nmeasure q2[1] -> cT1[1];\nmeasure q2[2] -> cT1[2];\nmeasure q2[3] -> cT1[3];\nmeasure q2[4] -> cT1[4];\nmeasure q2[5] -> cT1[5];\nmeasure q2[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log = cT1_log_raw;\nif(syn_measT1 == 2) cT_log = cT_log ^ 1;\nif(syn_measT1 == 4) cT_log = cT_log ^ 1;\nif(syn_measT1 == 6) cT_log = cT_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log = cT_log ^ pf[0];\n\n//Logical X\nif(cT_log[0] == 1) x q3[4];\nif(cT_log[0] == 1) x q3[5];\nif(cT_log[0] == 1) x q3[6];\n\nif(cT_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q2[4];\nif(cT2_log[0] == 1) x q2[5];\nif(cT2_log[0] == 1) x q2[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q0, q2;\ncx q0[0], q2[0];\ncx q0[1], q2[1];\ncx q0[2], q2[2];\ncx q0[3], q2[3];\ncx q0[4], q2[4];\ncx q0[5], q2[5];\ncx q0[6], q2[6];\nbarrier q0, q2;\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT3[0];\nmeasure q2[1] -> cT3[1];\nmeasure q2[2] -> cT3[2];\nmeasure q2[3] -> cT3[3];\nmeasure q2[4] -> cT3[4];\nmeasure q2[5] -> cT3[5];\nmeasure q2[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q2[4];\nif(cT4_log[0] == 1) x q2[5];\nif(cT4_log[0] == 1) x q2[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q2;\n// Logical H\nh q2;\nrz(-pi/2) q2;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT5[0];\nmeasure q2[1] -> cT5[1];\nmeasure q2[2] -> cT5[2];\nmeasure q2[3] -> cT5[3];\nmeasure q2[4] -> cT5[4];\nmeasure q2[5] -> cT5[5];\nmeasure q2[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c2[0];\nmeasure q3[1] -> c2[1];\nmeasure q3[2] -> c2[2];\nmeasure q3[3] -> c2[3];\nmeasure q3[4] -> c2[4];\nmeasure q3[5] -> c2[5];\nmeasure q3[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\n// Logical H\nif(c2_log[0] == 1) h q1;\n\n// Transversal Logical CX\nif(c2_log[0] == 1) barrier q0, q1;\nif(c2_log[0] == 1) cx q0[0], q1[0];\nif(c2_log[0] == 1) cx q0[1], q1[1];\nif(c2_log[0] == 1) cx q0[2], q1[2];\nif(c2_log[0] == 1) cx q0[3], q1[3];\nif(c2_log[0] == 1) cx q0[4], q1[4];\nif(c2_log[0] == 1) cx q0[5], q1[5];\nif(c2_log[0] == 1) cx q0[6], q1[6];\nif(c2_log[0] == 1) barrier q0, q1;\n\n// Logical H\nif(c2_log[0] == 1) h q1;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];"}, "5": {"parameters": "+1", "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg c[2];\ncreg c0[7];\ncreg c0_log_raw[1];\ncreg syn_meas0[3];\ncreg c0_log[1];\ncreg c1[7];\ncreg c1_log_raw[1];\ncreg syn_meas1[3];\ncreg c1_log[1];\ncreg c2[7];\ncreg c2_log_raw[1];\ncreg syn_meas2[3];\ncreg c2_log[1];\ncreg init[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\ncreg cT1[7];\ncreg cT1_log_raw[1];\ncreg syn_measT1[3];\ncreg cT_log[1];\ncreg cT2[7];\ncreg cT2_log_raw[1];\ncreg syn_measT2[3];\ncreg cT2_log[1];\ncreg cT3[7];\ncreg cT3_log_raw[1];\ncreg syn_measT3[3];\ncreg cT3_log[1];\ncreg cT4[7];\ncreg cT4_log_raw[1];\ncreg syn_measT4[3];\ncreg cT4_log[1];\ncreg cT5[7];\ncreg cT5_log_raw[1];\ncreg syn_measT5[3];\ncreg cT5_log[1];\ncreg cT6[7];\ncreg cT6_log_raw[1];\ncreg syn_measT6[3];\ncreg cT6_log[1];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n// Logical H\nh q0;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Logical H\nh q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT1[0];\nmeasure q2[1] -> cT1[1];\nmeasure q2[2] -> cT1[2];\nmeasure q2[3] -> cT1[3];\nmeasure q2[4] -> cT1[4];\nmeasure q2[5] -> cT1[5];\nmeasure q2[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log = cT1_log_raw;\nif(syn_measT1 == 2) cT_log = cT_log ^ 1;\nif(syn_measT1 == 4) cT_log = cT_log ^ 1;\nif(syn_measT1 == 6) cT_log = cT_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log = cT_log ^ pf[0];\n\n//Logical X\nif(cT_log[0] == 1) x q3[4];\nif(cT_log[0] == 1) x q3[5];\nif(cT_log[0] == 1) x q3[6];\n\nif(cT_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q2[4];\nif(cT2_log[0] == 1) x q2[5];\nif(cT2_log[0] == 1) x q2[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q0, q2;\ncx q0[0], q2[0];\ncx q0[1], q2[1];\ncx q0[2], q2[2];\ncx q0[3], q2[3];\ncx q0[4], q2[4];\ncx q0[5], q2[5];\ncx q0[6], q2[6];\nbarrier q0, q2;\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT3[0];\nmeasure q2[1] -> cT3[1];\nmeasure q2[2] -> cT3[2];\nmeasure q2[3] -> cT3[3];\nmeasure q2[4] -> cT3[4];\nmeasure q2[5] -> cT3[5];\nmeasure q2[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q2[4];\nif(cT4_log[0] == 1) x q2[5];\nif(cT4_log[0] == 1) x q2[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q2;\n// Logical H\nh q2;\nrz(-pi/2) q2;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT5[0];\nmeasure q2[1] -> cT5[1];\nmeasure q2[2] -> cT5[2];\nmeasure q2[3] -> cT5[3];\nmeasure q2[4] -> cT5[4];\nmeasure q2[5] -> cT5[5];\nmeasure q2[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c2[0];\nmeasure q3[1] -> c2[1];\nmeasure q3[2] -> c2[2];\nmeasure q3[3] -> c2[3];\nmeasure q3[4] -> c2[4];\nmeasure q3[5] -> c2[5];\nmeasure q3[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\n// Logical H\nif(c2_log[0] == 1) h q1;\n\n// Transversal Logical CX\nif(c2_log[0] == 1) barrier q0, q1;\nif(c2_log[0] == 1) cx q0[0], q1[0];\nif(c2_log[0] == 1) cx q0[1], q1[1];\nif(c2_log[0] == 1) cx q0[2], q1[2];\nif(c2_log[0] == 1) cx q0[3], q1[3];\nif(c2_log[0] == 1) cx q0[4], q1[4];\nif(c2_log[0] == 1) cx q0[5], q1[5];\nif(c2_log[0] == 1) cx q0[6], q1[6];\nif(c2_log[0] == 1) barrier q0, q1;\n\n// Logical H\nif(c2_log[0] == 1) h q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q0;\ncx q2[0], q0[0];\ncx q2[1], q0[1];\ncx q2[2], q0[2];\ncx q2[3], q0[3];\ncx q2[4], q0[4];\ncx q2[5], q0[5];\ncx q2[6], q0[6];\nbarrier q2, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT6[0];\nmeasure q0[1] -> cT6[1];\nmeasure q0[2] -> cT6[2];\nmeasure q0[3] -> cT6[3];\nmeasure q0[4] -> cT6[4];\nmeasure q0[5] -> cT6[5];\nmeasure q0[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q2[4];\nif(cT6_log[0] == 1) x q2[5];\nif(cT6_log[0] == 1) x q2[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Logical H\nh q2;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> c0[0];\nmeasure q2[1] -> c0[1];\nmeasure q2[2] -> c0[2];\nmeasure q2[3] -> c0[3];\nmeasure q2[4] -> c0[4];\nmeasure q2[5] -> c0[5];\nmeasure q2[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];"}, "6": {"parameters": "-0", "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg c[2];\ncreg c0[7];\ncreg c0_log_raw[1];\ncreg syn_meas0[3];\ncreg c0_log[1];\ncreg c1[7];\ncreg c1_log_raw[1];\ncreg syn_meas1[3];\ncreg c1_log[1];\ncreg c2[7];\ncreg c2_log_raw[1];\ncreg syn_meas2[3];\ncreg c2_log[1];\ncreg init[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\ncreg cT1[7];\ncreg cT1_log_raw[1];\ncreg syn_measT1[3];\ncreg cT_log[1];\ncreg cT2[7];\ncreg cT2_log_raw[1];\ncreg syn_measT2[3];\ncreg cT2_log[1];\ncreg cT3[7];\ncreg cT3_log_raw[1];\ncreg syn_measT3[3];\ncreg cT3_log[1];\ncreg cT4[7];\ncreg cT4_log_raw[1];\ncreg syn_measT4[3];\ncreg cT4_log[1];\ncreg cT5[7];\ncreg cT5_log_raw[1];\ncreg syn_measT5[3];\ncreg cT5_log[1];\ncreg cT6[7];\ncreg cT6_log_raw[1];\ncreg syn_measT6[3];\ncreg cT6_log[1];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Logical H\nh q0;\n// Logical H\nh q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT1[0];\nmeasure q2[1] -> cT1[1];\nmeasure q2[2] -> cT1[2];\nmeasure q2[3] -> cT1[3];\nmeasure q2[4] -> cT1[4];\nmeasure q2[5] -> cT1[5];\nmeasure q2[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log = cT1_log_raw;\nif(syn_measT1 == 2) cT_log = cT_log ^ 1;\nif(syn_measT1 == 4) cT_log = cT_log ^ 1;\nif(syn_measT1 == 6) cT_log = cT_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log = cT_log ^ pf[0];\n\n//Logical X\nif(cT_log[0] == 1) x q3[4];\nif(cT_log[0] == 1) x q3[5];\nif(cT_log[0] == 1) x q3[6];\n\nif(cT_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q2[4];\nif(cT2_log[0] == 1) x q2[5];\nif(cT2_log[0] == 1) x q2[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q0, q2;\ncx q0[0], q2[0];\ncx q0[1], q2[1];\ncx q0[2], q2[2];\ncx q0[3], q2[3];\ncx q0[4], q2[4];\ncx q0[5], q2[5];\ncx q0[6], q2[6];\nbarrier q0, q2;\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT3[0];\nmeasure q2[1] -> cT3[1];\nmeasure q2[2] -> cT3[2];\nmeasure q2[3] -> cT3[3];\nmeasure q2[4] -> cT3[4];\nmeasure q2[5] -> cT3[5];\nmeasure q2[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q2[4];\nif(cT4_log[0] == 1) x q2[5];\nif(cT4_log[0] == 1) x q2[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q2;\n// Logical H\nh q2;\nrz(-pi/2) q2;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT5[0];\nmeasure q2[1] -> cT5[1];\nmeasure q2[2] -> cT5[2];\nmeasure q2[3] -> cT5[3];\nmeasure q2[4] -> cT5[4];\nmeasure q2[5] -> cT5[5];\nmeasure q2[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c2[0];\nmeasure q3[1] -> c2[1];\nmeasure q3[2] -> c2[2];\nmeasure q3[3] -> c2[3];\nmeasure q3[4] -> c2[4];\nmeasure q3[5] -> c2[5];\nmeasure q3[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\n// Logical H\nif(c2_log[0] == 1) h q1;\n\n// Transversal Logical CX\nif(c2_log[0] == 1) barrier q0, q1;\nif(c2_log[0] == 1) cx q0[0], q1[0];\nif(c2_log[0] == 1) cx q0[1], q1[1];\nif(c2_log[0] == 1) cx q0[2], q1[2];\nif(c2_log[0] == 1) cx q0[3], q1[3];\nif(c2_log[0] == 1) cx q0[4], q1[4];\nif(c2_log[0] == 1) cx q0[5], q1[5];\nif(c2_log[0] == 1) cx q0[6], q1[6];\nif(c2_log[0] == 1) barrier q0, q1;\n\n// Logical H\nif(c2_log[0] == 1) h q1;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c0[0];\nmeasure q0[1] -> c0[1];\nmeasure q0[2] -> c0[2];\nmeasure q0[3] -> c0[3];\nmeasure q0[4] -> c0[4];\nmeasure q0[5] -> c0[5];\nmeasure q0[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];"}, "7": {"parameters": "-1", "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg c[2];\ncreg c0[7];\ncreg c0_log_raw[1];\ncreg syn_meas0[3];\ncreg c0_log[1];\ncreg c1[7];\ncreg c1_log_raw[1];\ncreg syn_meas1[3];\ncreg c1_log[1];\ncreg c2[7];\ncreg c2_log_raw[1];\ncreg syn_meas2[3];\ncreg c2_log[1];\ncreg init[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\ncreg cT1[7];\ncreg cT1_log_raw[1];\ncreg syn_measT1[3];\ncreg cT_log[1];\ncreg cT2[7];\ncreg cT2_log_raw[1];\ncreg syn_measT2[3];\ncreg cT2_log[1];\ncreg cT3[7];\ncreg cT3_log_raw[1];\ncreg syn_measT3[3];\ncreg cT3_log[1];\ncreg cT4[7];\ncreg cT4_log_raw[1];\ncreg syn_measT4[3];\ncreg cT4_log[1];\ncreg cT5[7];\ncreg cT5_log_raw[1];\ncreg syn_measT5[3];\ncreg cT5_log[1];\ncreg cT6[7];\ncreg cT6_log_raw[1];\ncreg syn_measT6[3];\ncreg cT6_log[1];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Logical H\nh q0;\n// Logical H\nh q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT1[0];\nmeasure q2[1] -> cT1[1];\nmeasure q2[2] -> cT1[2];\nmeasure q2[3] -> cT1[3];\nmeasure q2[4] -> cT1[4];\nmeasure q2[5] -> cT1[5];\nmeasure q2[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log = cT1_log_raw;\nif(syn_measT1 == 2) cT_log = cT_log ^ 1;\nif(syn_measT1 == 4) cT_log = cT_log ^ 1;\nif(syn_measT1 == 6) cT_log = cT_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log = cT_log ^ pf[0];\n\n//Logical X\nif(cT_log[0] == 1) x q3[4];\nif(cT_log[0] == 1) x q3[5];\nif(cT_log[0] == 1) x q3[6];\n\nif(cT_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q2[4];\nif(cT2_log[0] == 1) x q2[5];\nif(cT2_log[0] == 1) x q2[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q0, q2;\ncx q0[0], q2[0];\ncx q0[1], q2[1];\ncx q0[2], q2[2];\ncx q0[3], q2[3];\ncx q0[4], q2[4];\ncx q0[5], q2[5];\ncx q0[6], q2[6];\nbarrier q0, q2;\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT3[0];\nmeasure q2[1] -> cT3[1];\nmeasure q2[2] -> cT3[2];\nmeasure q2[3] -> cT3[3];\nmeasure q2[4] -> cT3[4];\nmeasure q2[5] -> cT3[5];\nmeasure q2[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q2[4];\nif(cT4_log[0] == 1) x q2[5];\nif(cT4_log[0] == 1) x q2[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q2;\n// Logical H\nh q2;\nrz(-pi/2) q2;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT5[0];\nmeasure q2[1] -> cT5[1];\nmeasure q2[2] -> cT5[2];\nmeasure q2[3] -> cT5[3];\nmeasure q2[4] -> cT5[4];\nmeasure q2[5] -> cT5[5];\nmeasure q2[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c2[0];\nmeasure q3[1] -> c2[1];\nmeasure q3[2] -> c2[2];\nmeasure q3[3] -> c2[3];\nmeasure q3[4] -> c2[4];\nmeasure q3[5] -> c2[5];\nmeasure q3[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\n// Logical H\nif(c2_log[0] == 1) h q1;\n\n// Transversal Logical CX\nif(c2_log[0] == 1) barrier q0, q1;\nif(c2_log[0] == 1) cx q0[0], q1[0];\nif(c2_log[0] == 1) cx q0[1], q1[1];\nif(c2_log[0] == 1) cx q0[2], q1[2];\nif(c2_log[0] == 1) cx q0[3], q1[3];\nif(c2_log[0] == 1) cx q0[4], q1[4];\nif(c2_log[0] == 1) cx q0[5], q1[5];\nif(c2_log[0] == 1) cx q0[6], q1[6];\nif(c2_log[0] == 1) barrier q0, q1;\n\n// Logical H\nif(c2_log[0] == 1) h q1;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q0;\ncx q2[0], q0[0];\ncx q2[1], q0[1];\ncx q2[2], q0[2];\ncx q2[3], q0[3];\ncx q2[4], q0[4];\ncx q2[5], q0[5];\ncx q2[6], q0[6];\nbarrier q2, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT6[0];\nmeasure q0[1] -> cT6[1];\nmeasure q0[2] -> cT6[2];\nmeasure q0[3] -> cT6[3];\nmeasure q0[4] -> cT6[4];\nmeasure q0[5] -> cT6[5];\nmeasure q0[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q2[4];\nif(cT6_log[0] == 1) x q2[5];\nif(cT6_log[0] == 1) x q2[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Logical H\nh q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> c0[0];\nmeasure q2[1] -> c0[1];\nmeasure q2[2] -> c0[2];\nmeasure q2[3] -> c0[3];\nmeasure q2[4] -> c0[4];\nmeasure q2[5] -> c0[5];\nmeasure q2[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];"}}