{"0": {"parameters": [16, 8, "0"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg cT13[7];\ncreg cT_log_raw13[1];\ncreg syn_measT13[3];\ncreg cT_log13[1];\ncreg cT14[7];\ncreg cT_log_raw14[1];\ncreg syn_measT14[3];\ncreg cT_log14[1];\ncreg cT15[7];\ncreg cT_log_raw15[1];\ncreg syn_measT15[3];\ncreg cT_log15[1];\ncreg cT16[7];\ncreg cT_log_raw16[1];\ncreg syn_measT16[3];\ncreg cT_log16[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT13[0];\nmeasure q1[1] -> cT13[1];\nmeasure q1[2] -> cT13[2];\nmeasure q1[3] -> cT13[3];\nmeasure q1[4] -> cT13[4];\nmeasure q1[5] -> cT13[5];\nmeasure q1[6] -> cT13[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw13 = cT13[4] ^ cT13[5] ^ cT13[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT13[0] = cT13[0] ^ cT13[1] ^ cT13[2] ^ cT13[3];\nsyn_measT13[1] = cT13[1] ^ cT13[2] ^ cT13[4] ^ cT13[5];\nsyn_measT13[2] = cT13[2] ^ cT13[3] ^ cT13[5] ^ cT13[6];\n\n// XOR syndromes\nsyn_measT13 = syn_measT13 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log13 = cT_log_raw13;\nif(syn_measT13 == 2) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 4) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 6) cT_log13 = cT_log13 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log13 = cT_log13 ^ pf[0];\nif(cT_log13[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT14[0];\nmeasure q1[1] -> cT14[1];\nmeasure q1[2] -> cT14[2];\nmeasure q1[3] -> cT14[3];\nmeasure q1[4] -> cT14[4];\nmeasure q1[5] -> cT14[5];\nmeasure q1[6] -> cT14[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw14 = cT14[4] ^ cT14[5] ^ cT14[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT14[0] = cT14[0] ^ cT14[1] ^ cT14[2] ^ cT14[3];\nsyn_measT14[1] = cT14[1] ^ cT14[2] ^ cT14[4] ^ cT14[5];\nsyn_measT14[2] = cT14[2] ^ cT14[3] ^ cT14[5] ^ cT14[6];\n\n// XOR syndromes\nsyn_measT14 = syn_measT14 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log14 = cT_log_raw14;\nif(syn_measT14 == 2) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 4) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 6) cT_log14 = cT_log14 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log14 = cT_log14 ^ pf[0];\nif(cT_log14[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT15[0];\nmeasure q1[1] -> cT15[1];\nmeasure q1[2] -> cT15[2];\nmeasure q1[3] -> cT15[3];\nmeasure q1[4] -> cT15[4];\nmeasure q1[5] -> cT15[5];\nmeasure q1[6] -> cT15[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw15 = cT15[4] ^ cT15[5] ^ cT15[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT15[0] = cT15[0] ^ cT15[1] ^ cT15[2] ^ cT15[3];\nsyn_measT15[1] = cT15[1] ^ cT15[2] ^ cT15[4] ^ cT15[5];\nsyn_measT15[2] = cT15[2] ^ cT15[3] ^ cT15[5] ^ cT15[6];\n\n// XOR syndromes\nsyn_measT15 = syn_measT15 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log15 = cT_log_raw15;\nif(syn_measT15 == 2) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 4) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 6) cT_log15 = cT_log15 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log15 = cT_log15 ^ pf[0];\nif(cT_log15[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT16[0];\nmeasure q1[1] -> cT16[1];\nmeasure q1[2] -> cT16[2];\nmeasure q1[3] -> cT16[3];\nmeasure q1[4] -> cT16[4];\nmeasure q1[5] -> cT16[5];\nmeasure q1[6] -> cT16[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw16 = cT16[4] ^ cT16[5] ^ cT16[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT16[0] = cT16[0] ^ cT16[1] ^ cT16[2] ^ cT16[3];\nsyn_measT16[1] = cT16[1] ^ cT16[2] ^ cT16[4] ^ cT16[5];\nsyn_measT16[2] = cT16[2] ^ cT16[3] ^ cT16[5] ^ cT16[6];\n\n// XOR syndromes\nsyn_measT16 = syn_measT16 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log16 = cT_log_raw16;\nif(syn_measT16 == 2) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 4) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 6) cT_log16 = cT_log16 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log16 = cT_log16 ^ pf[0];\nif(cT_log16[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "1": {"parameters": [8, 7, "0"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "2": {"parameters": [12, 5, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "3": {"parameters": [4, 2, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "4": {"parameters": [8, 1, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "5": {"parameters": [16, 4, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg cT13[7];\ncreg cT_log_raw13[1];\ncreg syn_measT13[3];\ncreg cT_log13[1];\ncreg cT14[7];\ncreg cT_log_raw14[1];\ncreg syn_measT14[3];\ncreg cT_log14[1];\ncreg cT15[7];\ncreg cT_log_raw15[1];\ncreg syn_measT15[3];\ncreg cT_log15[1];\ncreg cT16[7];\ncreg cT_log_raw16[1];\ncreg syn_measT16[3];\ncreg cT_log16[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT13[0];\nmeasure q1[1] -> cT13[1];\nmeasure q1[2] -> cT13[2];\nmeasure q1[3] -> cT13[3];\nmeasure q1[4] -> cT13[4];\nmeasure q1[5] -> cT13[5];\nmeasure q1[6] -> cT13[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw13 = cT13[4] ^ cT13[5] ^ cT13[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT13[0] = cT13[0] ^ cT13[1] ^ cT13[2] ^ cT13[3];\nsyn_measT13[1] = cT13[1] ^ cT13[2] ^ cT13[4] ^ cT13[5];\nsyn_measT13[2] = cT13[2] ^ cT13[3] ^ cT13[5] ^ cT13[6];\n\n// XOR syndromes\nsyn_measT13 = syn_measT13 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log13 = cT_log_raw13;\nif(syn_measT13 == 2) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 4) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 6) cT_log13 = cT_log13 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log13 = cT_log13 ^ pf[0];\nif(cT_log13[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT14[0];\nmeasure q1[1] -> cT14[1];\nmeasure q1[2] -> cT14[2];\nmeasure q1[3] -> cT14[3];\nmeasure q1[4] -> cT14[4];\nmeasure q1[5] -> cT14[5];\nmeasure q1[6] -> cT14[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw14 = cT14[4] ^ cT14[5] ^ cT14[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT14[0] = cT14[0] ^ cT14[1] ^ cT14[2] ^ cT14[3];\nsyn_measT14[1] = cT14[1] ^ cT14[2] ^ cT14[4] ^ cT14[5];\nsyn_measT14[2] = cT14[2] ^ cT14[3] ^ cT14[5] ^ cT14[6];\n\n// XOR syndromes\nsyn_measT14 = syn_measT14 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log14 = cT_log_raw14;\nif(syn_measT14 == 2) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 4) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 6) cT_log14 = cT_log14 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log14 = cT_log14 ^ pf[0];\nif(cT_log14[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT15[0];\nmeasure q1[1] -> cT15[1];\nmeasure q1[2] -> cT15[2];\nmeasure q1[3] -> cT15[3];\nmeasure q1[4] -> cT15[4];\nmeasure q1[5] -> cT15[5];\nmeasure q1[6] -> cT15[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw15 = cT15[4] ^ cT15[5] ^ cT15[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT15[0] = cT15[0] ^ cT15[1] ^ cT15[2] ^ cT15[3];\nsyn_measT15[1] = cT15[1] ^ cT15[2] ^ cT15[4] ^ cT15[5];\nsyn_measT15[2] = cT15[2] ^ cT15[3] ^ cT15[5] ^ cT15[6];\n\n// XOR syndromes\nsyn_measT15 = syn_measT15 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log15 = cT_log_raw15;\nif(syn_measT15 == 2) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 4) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 6) cT_log15 = cT_log15 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log15 = cT_log15 ^ pf[0];\nif(cT_log15[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT16[0];\nmeasure q1[1] -> cT16[1];\nmeasure q1[2] -> cT16[2];\nmeasure q1[3] -> cT16[3];\nmeasure q1[4] -> cT16[4];\nmeasure q1[5] -> cT16[5];\nmeasure q1[6] -> cT16[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw16 = cT16[4] ^ cT16[5] ^ cT16[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT16[0] = cT16[0] ^ cT16[1] ^ cT16[2] ^ cT16[3];\nsyn_measT16[1] = cT16[1] ^ cT16[2] ^ cT16[4] ^ cT16[5];\nsyn_measT16[2] = cT16[2] ^ cT16[3] ^ cT16[5] ^ cT16[6];\n\n// XOR syndromes\nsyn_measT16 = syn_measT16 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log16 = cT_log_raw16;\nif(syn_measT16 == 2) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 4) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 6) cT_log16 = cT_log16 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log16 = cT_log16 ^ pf[0];\nif(cT_log16[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "6": {"parameters": [8, 4, "0"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "7": {"parameters": [8, 5, "0"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "8": {"parameters": [8, 2, "0"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "9": {"parameters": [16, 6, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg cT13[7];\ncreg cT_log_raw13[1];\ncreg syn_measT13[3];\ncreg cT_log13[1];\ncreg cT14[7];\ncreg cT_log_raw14[1];\ncreg syn_measT14[3];\ncreg cT_log14[1];\ncreg cT15[7];\ncreg cT_log_raw15[1];\ncreg syn_measT15[3];\ncreg cT_log15[1];\ncreg cT16[7];\ncreg cT_log_raw16[1];\ncreg syn_measT16[3];\ncreg cT_log16[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT13[0];\nmeasure q1[1] -> cT13[1];\nmeasure q1[2] -> cT13[2];\nmeasure q1[3] -> cT13[3];\nmeasure q1[4] -> cT13[4];\nmeasure q1[5] -> cT13[5];\nmeasure q1[6] -> cT13[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw13 = cT13[4] ^ cT13[5] ^ cT13[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT13[0] = cT13[0] ^ cT13[1] ^ cT13[2] ^ cT13[3];\nsyn_measT13[1] = cT13[1] ^ cT13[2] ^ cT13[4] ^ cT13[5];\nsyn_measT13[2] = cT13[2] ^ cT13[3] ^ cT13[5] ^ cT13[6];\n\n// XOR syndromes\nsyn_measT13 = syn_measT13 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log13 = cT_log_raw13;\nif(syn_measT13 == 2) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 4) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 6) cT_log13 = cT_log13 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log13 = cT_log13 ^ pf[0];\nif(cT_log13[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT14[0];\nmeasure q1[1] -> cT14[1];\nmeasure q1[2] -> cT14[2];\nmeasure q1[3] -> cT14[3];\nmeasure q1[4] -> cT14[4];\nmeasure q1[5] -> cT14[5];\nmeasure q1[6] -> cT14[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw14 = cT14[4] ^ cT14[5] ^ cT14[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT14[0] = cT14[0] ^ cT14[1] ^ cT14[2] ^ cT14[3];\nsyn_measT14[1] = cT14[1] ^ cT14[2] ^ cT14[4] ^ cT14[5];\nsyn_measT14[2] = cT14[2] ^ cT14[3] ^ cT14[5] ^ cT14[6];\n\n// XOR syndromes\nsyn_measT14 = syn_measT14 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log14 = cT_log_raw14;\nif(syn_measT14 == 2) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 4) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 6) cT_log14 = cT_log14 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log14 = cT_log14 ^ pf[0];\nif(cT_log14[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT15[0];\nmeasure q1[1] -> cT15[1];\nmeasure q1[2] -> cT15[2];\nmeasure q1[3] -> cT15[3];\nmeasure q1[4] -> cT15[4];\nmeasure q1[5] -> cT15[5];\nmeasure q1[6] -> cT15[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw15 = cT15[4] ^ cT15[5] ^ cT15[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT15[0] = cT15[0] ^ cT15[1] ^ cT15[2] ^ cT15[3];\nsyn_measT15[1] = cT15[1] ^ cT15[2] ^ cT15[4] ^ cT15[5];\nsyn_measT15[2] = cT15[2] ^ cT15[3] ^ cT15[5] ^ cT15[6];\n\n// XOR syndromes\nsyn_measT15 = syn_measT15 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log15 = cT_log_raw15;\nif(syn_measT15 == 2) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 4) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 6) cT_log15 = cT_log15 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log15 = cT_log15 ^ pf[0];\nif(cT_log15[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT16[0];\nmeasure q1[1] -> cT16[1];\nmeasure q1[2] -> cT16[2];\nmeasure q1[3] -> cT16[3];\nmeasure q1[4] -> cT16[4];\nmeasure q1[5] -> cT16[5];\nmeasure q1[6] -> cT16[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw16 = cT16[4] ^ cT16[5] ^ cT16[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT16[0] = cT16[0] ^ cT16[1] ^ cT16[2] ^ cT16[3];\nsyn_measT16[1] = cT16[1] ^ cT16[2] ^ cT16[4] ^ cT16[5];\nsyn_measT16[2] = cT16[2] ^ cT16[3] ^ cT16[5] ^ cT16[6];\n\n// XOR syndromes\nsyn_measT16 = syn_measT16 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log16 = cT_log_raw16;\nif(syn_measT16 == 2) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 4) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 6) cT_log16 = cT_log16 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log16 = cT_log16 ^ pf[0];\nif(cT_log16[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "10": {"parameters": [12, 0, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "11": {"parameters": [16, 3, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg cT13[7];\ncreg cT_log_raw13[1];\ncreg syn_measT13[3];\ncreg cT_log13[1];\ncreg cT14[7];\ncreg cT_log_raw14[1];\ncreg syn_measT14[3];\ncreg cT_log14[1];\ncreg cT15[7];\ncreg cT_log_raw15[1];\ncreg syn_measT15[3];\ncreg cT_log15[1];\ncreg cT16[7];\ncreg cT_log_raw16[1];\ncreg syn_measT16[3];\ncreg cT_log16[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT13[0];\nmeasure q1[1] -> cT13[1];\nmeasure q1[2] -> cT13[2];\nmeasure q1[3] -> cT13[3];\nmeasure q1[4] -> cT13[4];\nmeasure q1[5] -> cT13[5];\nmeasure q1[6] -> cT13[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw13 = cT13[4] ^ cT13[5] ^ cT13[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT13[0] = cT13[0] ^ cT13[1] ^ cT13[2] ^ cT13[3];\nsyn_measT13[1] = cT13[1] ^ cT13[2] ^ cT13[4] ^ cT13[5];\nsyn_measT13[2] = cT13[2] ^ cT13[3] ^ cT13[5] ^ cT13[6];\n\n// XOR syndromes\nsyn_measT13 = syn_measT13 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log13 = cT_log_raw13;\nif(syn_measT13 == 2) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 4) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 6) cT_log13 = cT_log13 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log13 = cT_log13 ^ pf[0];\nif(cT_log13[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT14[0];\nmeasure q1[1] -> cT14[1];\nmeasure q1[2] -> cT14[2];\nmeasure q1[3] -> cT14[3];\nmeasure q1[4] -> cT14[4];\nmeasure q1[5] -> cT14[5];\nmeasure q1[6] -> cT14[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw14 = cT14[4] ^ cT14[5] ^ cT14[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT14[0] = cT14[0] ^ cT14[1] ^ cT14[2] ^ cT14[3];\nsyn_measT14[1] = cT14[1] ^ cT14[2] ^ cT14[4] ^ cT14[5];\nsyn_measT14[2] = cT14[2] ^ cT14[3] ^ cT14[5] ^ cT14[6];\n\n// XOR syndromes\nsyn_measT14 = syn_measT14 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log14 = cT_log_raw14;\nif(syn_measT14 == 2) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 4) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 6) cT_log14 = cT_log14 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log14 = cT_log14 ^ pf[0];\nif(cT_log14[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT15[0];\nmeasure q1[1] -> cT15[1];\nmeasure q1[2] -> cT15[2];\nmeasure q1[3] -> cT15[3];\nmeasure q1[4] -> cT15[4];\nmeasure q1[5] -> cT15[5];\nmeasure q1[6] -> cT15[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw15 = cT15[4] ^ cT15[5] ^ cT15[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT15[0] = cT15[0] ^ cT15[1] ^ cT15[2] ^ cT15[3];\nsyn_measT15[1] = cT15[1] ^ cT15[2] ^ cT15[4] ^ cT15[5];\nsyn_measT15[2] = cT15[2] ^ cT15[3] ^ cT15[5] ^ cT15[6];\n\n// XOR syndromes\nsyn_measT15 = syn_measT15 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log15 = cT_log_raw15;\nif(syn_measT15 == 2) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 4) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 6) cT_log15 = cT_log15 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log15 = cT_log15 ^ pf[0];\nif(cT_log15[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT16[0];\nmeasure q1[1] -> cT16[1];\nmeasure q1[2] -> cT16[2];\nmeasure q1[3] -> cT16[3];\nmeasure q1[4] -> cT16[4];\nmeasure q1[5] -> cT16[5];\nmeasure q1[6] -> cT16[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw16 = cT16[4] ^ cT16[5] ^ cT16[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT16[0] = cT16[0] ^ cT16[1] ^ cT16[2] ^ cT16[3];\nsyn_measT16[1] = cT16[1] ^ cT16[2] ^ cT16[4] ^ cT16[5];\nsyn_measT16[2] = cT16[2] ^ cT16[3] ^ cT16[5] ^ cT16[6];\n\n// XOR syndromes\nsyn_measT16 = syn_measT16 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log16 = cT_log_raw16;\nif(syn_measT16 == 2) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 4) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 6) cT_log16 = cT_log16 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log16 = cT_log16 ^ pf[0];\nif(cT_log16[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "12": {"parameters": [8, 0, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "13": {"parameters": [16, 1, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg cT13[7];\ncreg cT_log_raw13[1];\ncreg syn_measT13[3];\ncreg cT_log13[1];\ncreg cT14[7];\ncreg cT_log_raw14[1];\ncreg syn_measT14[3];\ncreg cT_log14[1];\ncreg cT15[7];\ncreg cT_log_raw15[1];\ncreg syn_measT15[3];\ncreg cT_log15[1];\ncreg cT16[7];\ncreg cT_log_raw16[1];\ncreg syn_measT16[3];\ncreg cT_log16[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT13[0];\nmeasure q1[1] -> cT13[1];\nmeasure q1[2] -> cT13[2];\nmeasure q1[3] -> cT13[3];\nmeasure q1[4] -> cT13[4];\nmeasure q1[5] -> cT13[5];\nmeasure q1[6] -> cT13[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw13 = cT13[4] ^ cT13[5] ^ cT13[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT13[0] = cT13[0] ^ cT13[1] ^ cT13[2] ^ cT13[3];\nsyn_measT13[1] = cT13[1] ^ cT13[2] ^ cT13[4] ^ cT13[5];\nsyn_measT13[2] = cT13[2] ^ cT13[3] ^ cT13[5] ^ cT13[6];\n\n// XOR syndromes\nsyn_measT13 = syn_measT13 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log13 = cT_log_raw13;\nif(syn_measT13 == 2) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 4) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 6) cT_log13 = cT_log13 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log13 = cT_log13 ^ pf[0];\nif(cT_log13[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT14[0];\nmeasure q1[1] -> cT14[1];\nmeasure q1[2] -> cT14[2];\nmeasure q1[3] -> cT14[3];\nmeasure q1[4] -> cT14[4];\nmeasure q1[5] -> cT14[5];\nmeasure q1[6] -> cT14[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw14 = cT14[4] ^ cT14[5] ^ cT14[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT14[0] = cT14[0] ^ cT14[1] ^ cT14[2] ^ cT14[3];\nsyn_measT14[1] = cT14[1] ^ cT14[2] ^ cT14[4] ^ cT14[5];\nsyn_measT14[2] = cT14[2] ^ cT14[3] ^ cT14[5] ^ cT14[6];\n\n// XOR syndromes\nsyn_measT14 = syn_measT14 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log14 = cT_log_raw14;\nif(syn_measT14 == 2) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 4) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 6) cT_log14 = cT_log14 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log14 = cT_log14 ^ pf[0];\nif(cT_log14[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT15[0];\nmeasure q1[1] -> cT15[1];\nmeasure q1[2] -> cT15[2];\nmeasure q1[3] -> cT15[3];\nmeasure q1[4] -> cT15[4];\nmeasure q1[5] -> cT15[5];\nmeasure q1[6] -> cT15[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw15 = cT15[4] ^ cT15[5] ^ cT15[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT15[0] = cT15[0] ^ cT15[1] ^ cT15[2] ^ cT15[3];\nsyn_measT15[1] = cT15[1] ^ cT15[2] ^ cT15[4] ^ cT15[5];\nsyn_measT15[2] = cT15[2] ^ cT15[3] ^ cT15[5] ^ cT15[6];\n\n// XOR syndromes\nsyn_measT15 = syn_measT15 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log15 = cT_log_raw15;\nif(syn_measT15 == 2) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 4) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 6) cT_log15 = cT_log15 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log15 = cT_log15 ^ pf[0];\nif(cT_log15[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT16[0];\nmeasure q1[1] -> cT16[1];\nmeasure q1[2] -> cT16[2];\nmeasure q1[3] -> cT16[3];\nmeasure q1[4] -> cT16[4];\nmeasure q1[5] -> cT16[5];\nmeasure q1[6] -> cT16[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw16 = cT16[4] ^ cT16[5] ^ cT16[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT16[0] = cT16[0] ^ cT16[1] ^ cT16[2] ^ cT16[3];\nsyn_measT16[1] = cT16[1] ^ cT16[2] ^ cT16[4] ^ cT16[5];\nsyn_measT16[2] = cT16[2] ^ cT16[3] ^ cT16[5] ^ cT16[6];\n\n// XOR syndromes\nsyn_measT16 = syn_measT16 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log16 = cT_log_raw16;\nif(syn_measT16 == 2) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 4) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 6) cT_log16 = cT_log16 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log16 = cT_log16 ^ pf[0];\nif(cT_log16[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "14": {"parameters": [8, 6, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "15": {"parameters": [8, 9, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "16": {"parameters": [4, 4, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "17": {"parameters": [16, 7, "0"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg cT13[7];\ncreg cT_log_raw13[1];\ncreg syn_measT13[3];\ncreg cT_log13[1];\ncreg cT14[7];\ncreg cT_log_raw14[1];\ncreg syn_measT14[3];\ncreg cT_log14[1];\ncreg cT15[7];\ncreg cT_log_raw15[1];\ncreg syn_measT15[3];\ncreg cT_log15[1];\ncreg cT16[7];\ncreg cT_log_raw16[1];\ncreg syn_measT16[3];\ncreg cT_log16[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT13[0];\nmeasure q1[1] -> cT13[1];\nmeasure q1[2] -> cT13[2];\nmeasure q1[3] -> cT13[3];\nmeasure q1[4] -> cT13[4];\nmeasure q1[5] -> cT13[5];\nmeasure q1[6] -> cT13[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw13 = cT13[4] ^ cT13[5] ^ cT13[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT13[0] = cT13[0] ^ cT13[1] ^ cT13[2] ^ cT13[3];\nsyn_measT13[1] = cT13[1] ^ cT13[2] ^ cT13[4] ^ cT13[5];\nsyn_measT13[2] = cT13[2] ^ cT13[3] ^ cT13[5] ^ cT13[6];\n\n// XOR syndromes\nsyn_measT13 = syn_measT13 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log13 = cT_log_raw13;\nif(syn_measT13 == 2) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 4) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 6) cT_log13 = cT_log13 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log13 = cT_log13 ^ pf[0];\nif(cT_log13[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT14[0];\nmeasure q1[1] -> cT14[1];\nmeasure q1[2] -> cT14[2];\nmeasure q1[3] -> cT14[3];\nmeasure q1[4] -> cT14[4];\nmeasure q1[5] -> cT14[5];\nmeasure q1[6] -> cT14[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw14 = cT14[4] ^ cT14[5] ^ cT14[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT14[0] = cT14[0] ^ cT14[1] ^ cT14[2] ^ cT14[3];\nsyn_measT14[1] = cT14[1] ^ cT14[2] ^ cT14[4] ^ cT14[5];\nsyn_measT14[2] = cT14[2] ^ cT14[3] ^ cT14[5] ^ cT14[6];\n\n// XOR syndromes\nsyn_measT14 = syn_measT14 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log14 = cT_log_raw14;\nif(syn_measT14 == 2) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 4) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 6) cT_log14 = cT_log14 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log14 = cT_log14 ^ pf[0];\nif(cT_log14[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT15[0];\nmeasure q1[1] -> cT15[1];\nmeasure q1[2] -> cT15[2];\nmeasure q1[3] -> cT15[3];\nmeasure q1[4] -> cT15[4];\nmeasure q1[5] -> cT15[5];\nmeasure q1[6] -> cT15[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw15 = cT15[4] ^ cT15[5] ^ cT15[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT15[0] = cT15[0] ^ cT15[1] ^ cT15[2] ^ cT15[3];\nsyn_measT15[1] = cT15[1] ^ cT15[2] ^ cT15[4] ^ cT15[5];\nsyn_measT15[2] = cT15[2] ^ cT15[3] ^ cT15[5] ^ cT15[6];\n\n// XOR syndromes\nsyn_measT15 = syn_measT15 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log15 = cT_log_raw15;\nif(syn_measT15 == 2) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 4) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 6) cT_log15 = cT_log15 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log15 = cT_log15 ^ pf[0];\nif(cT_log15[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT16[0];\nmeasure q1[1] -> cT16[1];\nmeasure q1[2] -> cT16[2];\nmeasure q1[3] -> cT16[3];\nmeasure q1[4] -> cT16[4];\nmeasure q1[5] -> cT16[5];\nmeasure q1[6] -> cT16[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw16 = cT16[4] ^ cT16[5] ^ cT16[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT16[0] = cT16[0] ^ cT16[1] ^ cT16[2] ^ cT16[3];\nsyn_measT16[1] = cT16[1] ^ cT16[2] ^ cT16[4] ^ cT16[5];\nsyn_measT16[2] = cT16[2] ^ cT16[3] ^ cT16[5] ^ cT16[6];\n\n// XOR syndromes\nsyn_measT16 = syn_measT16 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log16 = cT_log_raw16;\nif(syn_measT16 == 2) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 4) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 6) cT_log16 = cT_log16 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log16 = cT_log16 ^ pf[0];\nif(cT_log16[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "18": {"parameters": [12, 8, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "19": {"parameters": [4, 6, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "20": {"parameters": [12, 6, "0"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "21": {"parameters": [4, 0, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "22": {"parameters": [4, 5, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "23": {"parameters": [8, 3, "0"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "24": {"parameters": [12, 9, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "25": {"parameters": [8, 8, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "26": {"parameters": [16, 2, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg cT13[7];\ncreg cT_log_raw13[1];\ncreg syn_measT13[3];\ncreg cT_log13[1];\ncreg cT14[7];\ncreg cT_log_raw14[1];\ncreg syn_measT14[3];\ncreg cT_log14[1];\ncreg cT15[7];\ncreg cT_log_raw15[1];\ncreg syn_measT15[3];\ncreg cT_log15[1];\ncreg cT16[7];\ncreg cT_log_raw16[1];\ncreg syn_measT16[3];\ncreg cT_log16[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT13[0];\nmeasure q1[1] -> cT13[1];\nmeasure q1[2] -> cT13[2];\nmeasure q1[3] -> cT13[3];\nmeasure q1[4] -> cT13[4];\nmeasure q1[5] -> cT13[5];\nmeasure q1[6] -> cT13[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw13 = cT13[4] ^ cT13[5] ^ cT13[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT13[0] = cT13[0] ^ cT13[1] ^ cT13[2] ^ cT13[3];\nsyn_measT13[1] = cT13[1] ^ cT13[2] ^ cT13[4] ^ cT13[5];\nsyn_measT13[2] = cT13[2] ^ cT13[3] ^ cT13[5] ^ cT13[6];\n\n// XOR syndromes\nsyn_measT13 = syn_measT13 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log13 = cT_log_raw13;\nif(syn_measT13 == 2) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 4) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 6) cT_log13 = cT_log13 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log13 = cT_log13 ^ pf[0];\nif(cT_log13[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT14[0];\nmeasure q1[1] -> cT14[1];\nmeasure q1[2] -> cT14[2];\nmeasure q1[3] -> cT14[3];\nmeasure q1[4] -> cT14[4];\nmeasure q1[5] -> cT14[5];\nmeasure q1[6] -> cT14[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw14 = cT14[4] ^ cT14[5] ^ cT14[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT14[0] = cT14[0] ^ cT14[1] ^ cT14[2] ^ cT14[3];\nsyn_measT14[1] = cT14[1] ^ cT14[2] ^ cT14[4] ^ cT14[5];\nsyn_measT14[2] = cT14[2] ^ cT14[3] ^ cT14[5] ^ cT14[6];\n\n// XOR syndromes\nsyn_measT14 = syn_measT14 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log14 = cT_log_raw14;\nif(syn_measT14 == 2) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 4) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 6) cT_log14 = cT_log14 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log14 = cT_log14 ^ pf[0];\nif(cT_log14[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT15[0];\nmeasure q1[1] -> cT15[1];\nmeasure q1[2] -> cT15[2];\nmeasure q1[3] -> cT15[3];\nmeasure q1[4] -> cT15[4];\nmeasure q1[5] -> cT15[5];\nmeasure q1[6] -> cT15[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw15 = cT15[4] ^ cT15[5] ^ cT15[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT15[0] = cT15[0] ^ cT15[1] ^ cT15[2] ^ cT15[3];\nsyn_measT15[1] = cT15[1] ^ cT15[2] ^ cT15[4] ^ cT15[5];\nsyn_measT15[2] = cT15[2] ^ cT15[3] ^ cT15[5] ^ cT15[6];\n\n// XOR syndromes\nsyn_measT15 = syn_measT15 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log15 = cT_log_raw15;\nif(syn_measT15 == 2) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 4) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 6) cT_log15 = cT_log15 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log15 = cT_log15 ^ pf[0];\nif(cT_log15[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT16[0];\nmeasure q1[1] -> cT16[1];\nmeasure q1[2] -> cT16[2];\nmeasure q1[3] -> cT16[3];\nmeasure q1[4] -> cT16[4];\nmeasure q1[5] -> cT16[5];\nmeasure q1[6] -> cT16[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw16 = cT16[4] ^ cT16[5] ^ cT16[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT16[0] = cT16[0] ^ cT16[1] ^ cT16[2] ^ cT16[3];\nsyn_measT16[1] = cT16[1] ^ cT16[2] ^ cT16[4] ^ cT16[5];\nsyn_measT16[2] = cT16[2] ^ cT16[3] ^ cT16[5] ^ cT16[6];\n\n// XOR syndromes\nsyn_measT16 = syn_measT16 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log16 = cT_log_raw16;\nif(syn_measT16 == 2) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 4) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 6) cT_log16 = cT_log16 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log16 = cT_log16 ^ pf[0];\nif(cT_log16[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "27": {"parameters": [16, 5, "0"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg cT13[7];\ncreg cT_log_raw13[1];\ncreg syn_measT13[3];\ncreg cT_log13[1];\ncreg cT14[7];\ncreg cT_log_raw14[1];\ncreg syn_measT14[3];\ncreg cT_log14[1];\ncreg cT15[7];\ncreg cT_log_raw15[1];\ncreg syn_measT15[3];\ncreg cT_log15[1];\ncreg cT16[7];\ncreg cT_log_raw16[1];\ncreg syn_measT16[3];\ncreg cT_log16[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT13[0];\nmeasure q1[1] -> cT13[1];\nmeasure q1[2] -> cT13[2];\nmeasure q1[3] -> cT13[3];\nmeasure q1[4] -> cT13[4];\nmeasure q1[5] -> cT13[5];\nmeasure q1[6] -> cT13[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw13 = cT13[4] ^ cT13[5] ^ cT13[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT13[0] = cT13[0] ^ cT13[1] ^ cT13[2] ^ cT13[3];\nsyn_measT13[1] = cT13[1] ^ cT13[2] ^ cT13[4] ^ cT13[5];\nsyn_measT13[2] = cT13[2] ^ cT13[3] ^ cT13[5] ^ cT13[6];\n\n// XOR syndromes\nsyn_measT13 = syn_measT13 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log13 = cT_log_raw13;\nif(syn_measT13 == 2) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 4) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 6) cT_log13 = cT_log13 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log13 = cT_log13 ^ pf[0];\nif(cT_log13[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT14[0];\nmeasure q1[1] -> cT14[1];\nmeasure q1[2] -> cT14[2];\nmeasure q1[3] -> cT14[3];\nmeasure q1[4] -> cT14[4];\nmeasure q1[5] -> cT14[5];\nmeasure q1[6] -> cT14[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw14 = cT14[4] ^ cT14[5] ^ cT14[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT14[0] = cT14[0] ^ cT14[1] ^ cT14[2] ^ cT14[3];\nsyn_measT14[1] = cT14[1] ^ cT14[2] ^ cT14[4] ^ cT14[5];\nsyn_measT14[2] = cT14[2] ^ cT14[3] ^ cT14[5] ^ cT14[6];\n\n// XOR syndromes\nsyn_measT14 = syn_measT14 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log14 = cT_log_raw14;\nif(syn_measT14 == 2) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 4) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 6) cT_log14 = cT_log14 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log14 = cT_log14 ^ pf[0];\nif(cT_log14[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT15[0];\nmeasure q1[1] -> cT15[1];\nmeasure q1[2] -> cT15[2];\nmeasure q1[3] -> cT15[3];\nmeasure q1[4] -> cT15[4];\nmeasure q1[5] -> cT15[5];\nmeasure q1[6] -> cT15[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw15 = cT15[4] ^ cT15[5] ^ cT15[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT15[0] = cT15[0] ^ cT15[1] ^ cT15[2] ^ cT15[3];\nsyn_measT15[1] = cT15[1] ^ cT15[2] ^ cT15[4] ^ cT15[5];\nsyn_measT15[2] = cT15[2] ^ cT15[3] ^ cT15[5] ^ cT15[6];\n\n// XOR syndromes\nsyn_measT15 = syn_measT15 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log15 = cT_log_raw15;\nif(syn_measT15 == 2) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 4) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 6) cT_log15 = cT_log15 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log15 = cT_log15 ^ pf[0];\nif(cT_log15[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT16[0];\nmeasure q1[1] -> cT16[1];\nmeasure q1[2] -> cT16[2];\nmeasure q1[3] -> cT16[3];\nmeasure q1[4] -> cT16[4];\nmeasure q1[5] -> cT16[5];\nmeasure q1[6] -> cT16[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw16 = cT16[4] ^ cT16[5] ^ cT16[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT16[0] = cT16[0] ^ cT16[1] ^ cT16[2] ^ cT16[3];\nsyn_measT16[1] = cT16[1] ^ cT16[2] ^ cT16[4] ^ cT16[5];\nsyn_measT16[2] = cT16[2] ^ cT16[3] ^ cT16[5] ^ cT16[6];\n\n// XOR syndromes\nsyn_measT16 = syn_measT16 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log16 = cT_log_raw16;\nif(syn_measT16 == 2) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 4) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 6) cT_log16 = cT_log16 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log16 = cT_log16 ^ pf[0];\nif(cT_log16[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "28": {"parameters": [16, 0, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg cT13[7];\ncreg cT_log_raw13[1];\ncreg syn_measT13[3];\ncreg cT_log13[1];\ncreg cT14[7];\ncreg cT_log_raw14[1];\ncreg syn_measT14[3];\ncreg cT_log14[1];\ncreg cT15[7];\ncreg cT_log_raw15[1];\ncreg syn_measT15[3];\ncreg cT_log15[1];\ncreg cT16[7];\ncreg cT_log_raw16[1];\ncreg syn_measT16[3];\ncreg cT_log16[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT13[0];\nmeasure q1[1] -> cT13[1];\nmeasure q1[2] -> cT13[2];\nmeasure q1[3] -> cT13[3];\nmeasure q1[4] -> cT13[4];\nmeasure q1[5] -> cT13[5];\nmeasure q1[6] -> cT13[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw13 = cT13[4] ^ cT13[5] ^ cT13[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT13[0] = cT13[0] ^ cT13[1] ^ cT13[2] ^ cT13[3];\nsyn_measT13[1] = cT13[1] ^ cT13[2] ^ cT13[4] ^ cT13[5];\nsyn_measT13[2] = cT13[2] ^ cT13[3] ^ cT13[5] ^ cT13[6];\n\n// XOR syndromes\nsyn_measT13 = syn_measT13 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log13 = cT_log_raw13;\nif(syn_measT13 == 2) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 4) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 6) cT_log13 = cT_log13 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log13 = cT_log13 ^ pf[0];\nif(cT_log13[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT14[0];\nmeasure q1[1] -> cT14[1];\nmeasure q1[2] -> cT14[2];\nmeasure q1[3] -> cT14[3];\nmeasure q1[4] -> cT14[4];\nmeasure q1[5] -> cT14[5];\nmeasure q1[6] -> cT14[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw14 = cT14[4] ^ cT14[5] ^ cT14[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT14[0] = cT14[0] ^ cT14[1] ^ cT14[2] ^ cT14[3];\nsyn_measT14[1] = cT14[1] ^ cT14[2] ^ cT14[4] ^ cT14[5];\nsyn_measT14[2] = cT14[2] ^ cT14[3] ^ cT14[5] ^ cT14[6];\n\n// XOR syndromes\nsyn_measT14 = syn_measT14 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log14 = cT_log_raw14;\nif(syn_measT14 == 2) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 4) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 6) cT_log14 = cT_log14 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log14 = cT_log14 ^ pf[0];\nif(cT_log14[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT15[0];\nmeasure q1[1] -> cT15[1];\nmeasure q1[2] -> cT15[2];\nmeasure q1[3] -> cT15[3];\nmeasure q1[4] -> cT15[4];\nmeasure q1[5] -> cT15[5];\nmeasure q1[6] -> cT15[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw15 = cT15[4] ^ cT15[5] ^ cT15[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT15[0] = cT15[0] ^ cT15[1] ^ cT15[2] ^ cT15[3];\nsyn_measT15[1] = cT15[1] ^ cT15[2] ^ cT15[4] ^ cT15[5];\nsyn_measT15[2] = cT15[2] ^ cT15[3] ^ cT15[5] ^ cT15[6];\n\n// XOR syndromes\nsyn_measT15 = syn_measT15 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log15 = cT_log_raw15;\nif(syn_measT15 == 2) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 4) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 6) cT_log15 = cT_log15 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log15 = cT_log15 ^ pf[0];\nif(cT_log15[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT16[0];\nmeasure q1[1] -> cT16[1];\nmeasure q1[2] -> cT16[2];\nmeasure q1[3] -> cT16[3];\nmeasure q1[4] -> cT16[4];\nmeasure q1[5] -> cT16[5];\nmeasure q1[6] -> cT16[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw16 = cT16[4] ^ cT16[5] ^ cT16[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT16[0] = cT16[0] ^ cT16[1] ^ cT16[2] ^ cT16[3];\nsyn_measT16[1] = cT16[1] ^ cT16[2] ^ cT16[4] ^ cT16[5];\nsyn_measT16[2] = cT16[2] ^ cT16[3] ^ cT16[5] ^ cT16[6];\n\n// XOR syndromes\nsyn_measT16 = syn_measT16 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log16 = cT_log_raw16;\nif(syn_measT16 == 2) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 4) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 6) cT_log16 = cT_log16 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log16 = cT_log16 ^ pf[0];\nif(cT_log16[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "29": {"parameters": [4, 9, "0"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "30": {"parameters": [12, 7, "0"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "31": {"parameters": [12, 1, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "32": {"parameters": [12, 3, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "33": {"parameters": [12, 4, "0"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "34": {"parameters": [4, 7, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "35": {"parameters": [16, 9, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg cT13[7];\ncreg cT_log_raw13[1];\ncreg syn_measT13[3];\ncreg cT_log13[1];\ncreg cT14[7];\ncreg cT_log_raw14[1];\ncreg syn_measT14[3];\ncreg cT_log14[1];\ncreg cT15[7];\ncreg cT_log_raw15[1];\ncreg syn_measT15[3];\ncreg cT_log15[1];\ncreg cT16[7];\ncreg cT_log_raw16[1];\ncreg syn_measT16[3];\ncreg cT_log16[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT13[0];\nmeasure q1[1] -> cT13[1];\nmeasure q1[2] -> cT13[2];\nmeasure q1[3] -> cT13[3];\nmeasure q1[4] -> cT13[4];\nmeasure q1[5] -> cT13[5];\nmeasure q1[6] -> cT13[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw13 = cT13[4] ^ cT13[5] ^ cT13[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT13[0] = cT13[0] ^ cT13[1] ^ cT13[2] ^ cT13[3];\nsyn_measT13[1] = cT13[1] ^ cT13[2] ^ cT13[4] ^ cT13[5];\nsyn_measT13[2] = cT13[2] ^ cT13[3] ^ cT13[5] ^ cT13[6];\n\n// XOR syndromes\nsyn_measT13 = syn_measT13 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log13 = cT_log_raw13;\nif(syn_measT13 == 2) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 4) cT_log13 = cT_log13 ^ 1;\nif(syn_measT13 == 6) cT_log13 = cT_log13 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log13 = cT_log13 ^ pf[0];\nif(cT_log13[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT14[0];\nmeasure q1[1] -> cT14[1];\nmeasure q1[2] -> cT14[2];\nmeasure q1[3] -> cT14[3];\nmeasure q1[4] -> cT14[4];\nmeasure q1[5] -> cT14[5];\nmeasure q1[6] -> cT14[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw14 = cT14[4] ^ cT14[5] ^ cT14[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT14[0] = cT14[0] ^ cT14[1] ^ cT14[2] ^ cT14[3];\nsyn_measT14[1] = cT14[1] ^ cT14[2] ^ cT14[4] ^ cT14[5];\nsyn_measT14[2] = cT14[2] ^ cT14[3] ^ cT14[5] ^ cT14[6];\n\n// XOR syndromes\nsyn_measT14 = syn_measT14 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log14 = cT_log_raw14;\nif(syn_measT14 == 2) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 4) cT_log14 = cT_log14 ^ 1;\nif(syn_measT14 == 6) cT_log14 = cT_log14 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log14 = cT_log14 ^ pf[0];\nif(cT_log14[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT15[0];\nmeasure q1[1] -> cT15[1];\nmeasure q1[2] -> cT15[2];\nmeasure q1[3] -> cT15[3];\nmeasure q1[4] -> cT15[4];\nmeasure q1[5] -> cT15[5];\nmeasure q1[6] -> cT15[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw15 = cT15[4] ^ cT15[5] ^ cT15[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT15[0] = cT15[0] ^ cT15[1] ^ cT15[2] ^ cT15[3];\nsyn_measT15[1] = cT15[1] ^ cT15[2] ^ cT15[4] ^ cT15[5];\nsyn_measT15[2] = cT15[2] ^ cT15[3] ^ cT15[5] ^ cT15[6];\n\n// XOR syndromes\nsyn_measT15 = syn_measT15 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log15 = cT_log_raw15;\nif(syn_measT15 == 2) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 4) cT_log15 = cT_log15 ^ 1;\nif(syn_measT15 == 6) cT_log15 = cT_log15 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log15 = cT_log15 ^ pf[0];\nif(cT_log15[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT16[0];\nmeasure q1[1] -> cT16[1];\nmeasure q1[2] -> cT16[2];\nmeasure q1[3] -> cT16[3];\nmeasure q1[4] -> cT16[4];\nmeasure q1[5] -> cT16[5];\nmeasure q1[6] -> cT16[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw16 = cT16[4] ^ cT16[5] ^ cT16[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT16[0] = cT16[0] ^ cT16[1] ^ cT16[2] ^ cT16[3];\nsyn_measT16[1] = cT16[1] ^ cT16[2] ^ cT16[4] ^ cT16[5];\nsyn_measT16[2] = cT16[2] ^ cT16[3] ^ cT16[5] ^ cT16[6];\n\n// XOR syndromes\nsyn_measT16 = syn_measT16 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log16 = cT_log_raw16;\nif(syn_measT16 == 2) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 4) cT_log16 = cT_log16 ^ 1;\nif(syn_measT16 == 6) cT_log16 = cT_log16 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log16 = cT_log16 ^ pf[0];\nif(cT_log16[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "36": {"parameters": [4, 3, "0"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "37": {"parameters": [4, 8, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "38": {"parameters": [4, 1, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}, "39": {"parameters": [12, 2, "1"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\ncreg c[7];\ncreg c_log_raw[1];\ncreg syn_meas[3];\ncreg c_log[1];\ncreg cT1[7];\ncreg cT_log_raw1[1];\ncreg syn_measT1[3];\ncreg cT_log1[1];\ncreg cT2[7];\ncreg cT_log_raw2[1];\ncreg syn_measT2[3];\ncreg cT_log2[1];\ncreg cT3[7];\ncreg cT_log_raw3[1];\ncreg syn_measT3[3];\ncreg cT_log3[1];\ncreg cT4[7];\ncreg cT_log_raw4[1];\ncreg syn_measT4[3];\ncreg cT_log4[1];\ncreg cT5[7];\ncreg cT_log_raw5[1];\ncreg syn_measT5[3];\ncreg cT_log5[1];\ncreg cT6[7];\ncreg cT_log_raw6[1];\ncreg syn_measT6[3];\ncreg cT_log6[1];\ncreg cT7[7];\ncreg cT_log_raw7[1];\ncreg syn_measT7[3];\ncreg cT_log7[1];\ncreg cT8[7];\ncreg cT_log_raw8[1];\ncreg syn_measT8[3];\ncreg cT_log8[1];\ncreg cT9[7];\ncreg cT_log_raw9[1];\ncreg syn_measT9[3];\ncreg cT_log9[1];\ncreg cT10[7];\ncreg cT_log_raw10[1];\ncreg syn_measT10[3];\ncreg cT_log10[1];\ncreg cT11[7];\ncreg cT_log_raw11[1];\ncreg syn_measT11[3];\ncreg cT_log11[1];\ncreg cT12[7];\ncreg cT_log_raw12[1];\ncreg syn_measT12[3];\ncreg cT_log12[1];\ncreg init[1];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nreset q0;\nreset q1[0];\nbarrier q0, q1[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q1[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q1[0];\ncx q0[1],q1[0];\ncx q0[3],q1[0];\nmeasure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q1[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q1[0];\nif(init[0] == 1) barrier q0, q1[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q1[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q1[0];\nif(init[0] == 1) cx q0[1],q1[0];\nif(init[0] == 1) cx q0[3],q1[0];\nif(init[0] == 1) measure q1[0] -> init[0];\n\n\n// Logical H\nh q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw1 = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log1 = cT_log_raw1;\nif(syn_measT1 == 2) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 4) cT_log1 = cT_log1 ^ 1;\nif(syn_measT1 == 6) cT_log1 = cT_log1 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log1 = cT_log1 ^ pf[0];\nif(cT_log1[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT2[0];\nmeasure q1[1] -> cT2[1];\nmeasure q1[2] -> cT2[2];\nmeasure q1[3] -> cT2[3];\nmeasure q1[4] -> cT2[4];\nmeasure q1[5] -> cT2[5];\nmeasure q1[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw2 = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log2 = cT_log_raw2;\nif(syn_measT2 == 2) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 4) cT_log2 = cT_log2 ^ 1;\nif(syn_measT2 == 6) cT_log2 = cT_log2 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log2 = cT_log2 ^ pf[0];\nif(cT_log2[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw3 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log3 = cT_log_raw3;\nif(syn_measT3 == 2) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 4) cT_log3 = cT_log3 ^ 1;\nif(syn_measT3 == 6) cT_log3 = cT_log3 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log3 = cT_log3 ^ pf[0];\nif(cT_log3[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw4 = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT4[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT4[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log4 = cT_log_raw4;\nif(syn_measT4 == 2) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 4) cT_log4 = cT_log4 ^ 1;\nif(syn_measT4 == 6) cT_log4 = cT_log4 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log4 = cT_log4 ^ pf[0];\nif(cT_log4[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw5 = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log5 = cT_log_raw5;\nif(syn_measT5 == 2) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 4) cT_log5 = cT_log5 ^ 1;\nif(syn_measT5 == 6) cT_log5 = cT_log5 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log5 = cT_log5 ^ pf[0];\nif(cT_log5[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT6[0];\nmeasure q1[1] -> cT6[1];\nmeasure q1[2] -> cT6[2];\nmeasure q1[3] -> cT6[3];\nmeasure q1[4] -> cT6[4];\nmeasure q1[5] -> cT6[5];\nmeasure q1[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw6 = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log6 = cT_log_raw6;\nif(syn_measT6 == 2) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 4) cT_log6 = cT_log6 ^ 1;\nif(syn_measT6 == 6) cT_log6 = cT_log6 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log6 = cT_log6 ^ pf[0];\nif(cT_log6[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw7 = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log7 = cT_log_raw7;\nif(syn_measT7 == 2) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 4) cT_log7 = cT_log7 ^ 1;\nif(syn_measT7 == 6) cT_log7 = cT_log7 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log7 = cT_log7 ^ pf[0];\nif(cT_log7[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT8[0];\nmeasure q1[1] -> cT8[1];\nmeasure q1[2] -> cT8[2];\nmeasure q1[3] -> cT8[3];\nmeasure q1[4] -> cT8[4];\nmeasure q1[5] -> cT8[5];\nmeasure q1[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw8 = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log8 = cT_log_raw8;\nif(syn_measT8 == 2) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 4) cT_log8 = cT_log8 ^ 1;\nif(syn_measT8 == 6) cT_log8 = cT_log8 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log8 = cT_log8 ^ pf[0];\nif(cT_log8[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw9 = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log9 = cT_log_raw9;\nif(syn_measT9 == 2) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 4) cT_log9 = cT_log9 ^ 1;\nif(syn_measT9 == 6) cT_log9 = cT_log9 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log9 = cT_log9 ^ pf[0];\nif(cT_log9[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT10[0];\nmeasure q1[1] -> cT10[1];\nmeasure q1[2] -> cT10[2];\nmeasure q1[3] -> cT10[3];\nmeasure q1[4] -> cT10[4];\nmeasure q1[5] -> cT10[5];\nmeasure q1[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw10 = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log10 = cT_log_raw10;\nif(syn_measT10 == 2) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 4) cT_log10 = cT_log10 ^ 1;\nif(syn_measT10 == 6) cT_log10 = cT_log10 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log10 = cT_log10 ^ pf[0];\nif(cT_log10[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT11[0];\nmeasure q1[1] -> cT11[1];\nmeasure q1[2] -> cT11[2];\nmeasure q1[3] -> cT11[3];\nmeasure q1[4] -> cT11[4];\nmeasure q1[5] -> cT11[5];\nmeasure q1[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw11 = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log11 = cT_log_raw11;\nif(syn_measT11 == 2) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 4) cT_log11 = cT_log11 ^ 1;\nif(syn_measT11 == 6) cT_log11 = cT_log11 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log11 = cT_log11 ^ pf[0];\nif(cT_log11[0] == 1) rz(-pi/2) q0;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT12[0];\nmeasure q1[1] -> cT12[1];\nmeasure q1[2] -> cT12[2];\nmeasure q1[3] -> cT12[3];\nmeasure q1[4] -> cT12[4];\nmeasure q1[5] -> cT12[5];\nmeasure q1[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT_log_raw12 = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT_log12 = cT_log_raw12;\nif(syn_measT12 == 2) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 4) cT_log12 = cT_log12 ^ 1;\nif(syn_measT12 == 6) cT_log12 = cT_log12 ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT_log12 = cT_log12 ^ pf[0];\nif(cT_log12[0] == 1) rz(-pi/2) q0;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c[0];\nmeasure q0[1] -> c[1];\nmeasure q0[2] -> c[2];\nmeasure q0[3] -> c[3];\nmeasure q0[4] -> c[4];\nmeasure q0[5] -> c[5];\nmeasure q0[6] -> c[6];\n\n// determine raw logical output\n// ============================\nc_log_raw = c[4] ^ c[5] ^ c[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas[0] = c[0] ^ c[1] ^ c[2] ^ c[3];\nsyn_meas[1] = c[1] ^ c[2] ^ c[4] ^ c[5];\nsyn_meas[2] = c[2] ^ c[3] ^ c[5] ^ c[6];\n\n// XOR syndromes\nsyn_meas = syn_meas ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_log = c_log_raw;\nif(syn_meas == 2) c_log = c_log ^ 1;\nif(syn_meas == 4) c_log = c_log ^ 1;\nif(syn_meas == 6) c_log = c_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_log = c_log ^ pf[0];"}}