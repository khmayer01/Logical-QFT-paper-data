{"0": {"parameters": ["comp", "101"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg init[4];\ncreg c0[7];\ncreg c1[7];\ncreg c2[7];\ncreg c0_log_raw[7];\ncreg c1_log_raw[7];\ncreg c2_log_raw[7];\ncreg c0_log[7];\ncreg c1_log[7];\ncreg c2_log[7];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\ncreg syn_meas2[3];\ncreg c[3];\ncreg c_mid[7];\ncreg c_mid_log_raw[1];\ncreg c_mid_log[1];\ncreg syn_meas_mid[3];\ncreg cT1[7];\ncreg cT2[7];\ncreg cT3[7];\ncreg cT4[7];\ncreg cT5[7];\ncreg cT6[7];\ncreg cT7[7];\ncreg cT8[7];\ncreg cT9[7];\ncreg cT10[7];\ncreg cT11[7];\ncreg cT12[7];\ncreg cT13[7];\ncreg cT1_log_raw[1];\ncreg cT2_log_raw[1];\ncreg cT3_log_raw[1];\ncreg cT4_log_raw[1];\ncreg cT5_log_raw[1];\ncreg cT6_log_raw[1];\ncreg cT7_log_raw[1];\ncreg cT8_log_raw[1];\ncreg cT9_log_raw[1];\ncreg cT10_log_raw[1];\ncreg cT11_log_raw[1];\ncreg cT12_log_raw[1];\ncreg cT13_log_raw[1];\ncreg cT1_log[1];\ncreg cT2_log[1];\ncreg cT3_log[1];\ncreg cT4_log[1];\ncreg cT5_log[1];\ncreg cT6_log[1];\ncreg cT7_log[1];\ncreg cT8_log[1];\ncreg cT9_log[1];\ncreg cT10_log[1];\ncreg cT11_log[1];\ncreg cT12_log[1];\ncreg cT13_log[1];\ncreg syn_measT1[3];\ncreg syn_measT2[3];\ncreg syn_measT3[3];\ncreg syn_measT4[3];\ncreg syn_measT5[3];\ncreg syn_measT6[3];\ncreg syn_measT7[3];\ncreg syn_measT8[3];\ncreg syn_measT9[3];\ncreg syn_measT10[3];\ncreg syn_measT11[3];\ncreg syn_measT12[3];\ncreg syn_measT13[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Logical H\nh q2;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT1_log = cT1_log_raw;\nif(syn_measT1 == 2) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 4) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 6) cT1_log = cT1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT1_log = cT1_log ^ pf[0];\n\n//Logical X\nif(cT1_log[0] == 1) x q3[4];\nif(cT1_log[0] == 1) x q3[5];\nif(cT1_log[0] == 1) x q3[6];\n\nif(cT1_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q1[4];\nif(cT2_log[0] == 1) x q1[5];\nif(cT2_log[0] == 1) x q1[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q1[4];\nif(cT4_log[0] == 1) x q1[5];\nif(cT4_log[0] == 1) x q1[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c_mid[0];\nmeasure q3[1] -> c_mid[1];\nmeasure q3[2] -> c_mid[2];\nmeasure q3[3] -> c_mid[3];\nmeasure q3[4] -> c_mid[4];\nmeasure q3[5] -> c_mid[5];\nmeasure q3[6] -> c_mid[6];\n\n// determine raw logical output\n// ============================\nc_mid_log_raw = c_mid[4] ^ c_mid[5] ^ c_mid[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas_mid[0] = c_mid[0] ^ c_mid[1] ^ c_mid[2] ^ c_mid[3];\nsyn_meas_mid[1] = c_mid[1] ^ c_mid[2] ^ c_mid[4] ^ c_mid[5];\nsyn_meas_mid[2] = c_mid[2] ^ c_mid[3] ^ c_mid[5] ^ c_mid[6];\n\n// XOR syndromes\nsyn_meas_mid = syn_meas_mid ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_mid_log = c_mid_log_raw;\nif(syn_meas_mid == 2) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 4) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 6) c_mid_log = c_mid_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_mid_log = c_mid_log ^ pf[0];\n// Logical H\nif(c_mid_log[0] == 1) h q2;\n\n// Transversal Logical CX\nif(c_mid_log[0] == 1) barrier q0, q2;\nif(c_mid_log[0] == 1) cx q0[0], q2[0];\nif(c_mid_log[0] == 1) cx q0[1], q2[1];\nif(c_mid_log[0] == 1) cx q0[2], q2[2];\nif(c_mid_log[0] == 1) cx q0[3], q2[3];\nif(c_mid_log[0] == 1) cx q0[4], q2[4];\nif(c_mid_log[0] == 1) cx q0[5], q2[5];\nif(c_mid_log[0] == 1) cx q0[6], q2[6];\nif(c_mid_log[0] == 1) barrier q0, q2;\n\n// Logical H\nif(c_mid_log[0] == 1) h q2;\nreset q3;\n\nbarrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nreset q3;\nreset q1[0];\nbarrier q3, q1[0];\n\nh q3[0];\nh q3[4];\nh q3[6];\n\ncx q3[4],q3[5];\ncx q3[0],q3[1];\ncx q3[6],q3[3];\ncx q3[4],q3[2];\ncx q3[6],q3[5];\ncx q3[0],q3[3];\ncx q3[4],q3[1];\ncx q3[3], q3[2];\n\nbarrier q1[0],q3[1],q3[3],q3[5];\n//verification step\ncx q3[5],q1[0];\ncx q3[1],q1[0];\ncx q3[3],q1[0];\nmeasure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q2;\ncx q1[0], q2[0];\ncx q1[1], q2[1];\ncx q1[2], q2[2];\ncx q1[3], q2[3];\ncx q1[4], q2[4];\ncx q1[5], q2[5];\ncx q1[6], q2[6];\nbarrier q1, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT6[0];\nmeasure q2[1] -> cT6[1];\nmeasure q2[2] -> cT6[2];\nmeasure q2[3] -> cT6[3];\nmeasure q2[4] -> cT6[4];\nmeasure q2[5] -> cT6[5];\nmeasure q2[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q1[4];\nif(cT6_log[0] == 1) x q1[5];\nif(cT6_log[0] == 1) x q1[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT7_log_raw = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT7_log = cT7_log_raw;\nif(syn_measT7 == 2) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 4) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 6) cT7_log = cT7_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT7_log = cT7_log ^ pf[0];\n\n//Logical X\nif(cT7_log[0] == 1) x q2[4];\nif(cT7_log[0] == 1) x q2[5];\nif(cT7_log[0] == 1) x q2[6];\n\nif(cT7_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT8[0];\nmeasure q3[1] -> cT8[1];\nmeasure q3[2] -> cT8[2];\nmeasure q3[3] -> cT8[3];\nmeasure q3[4] -> cT8[4];\nmeasure q3[5] -> cT8[5];\nmeasure q3[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT8_log_raw = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT8_log = cT8_log_raw;\nif(syn_measT8 == 2) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 4) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 6) cT8_log = cT8_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT8_log = cT8_log ^ pf[0];\n\n//Logical X\nif(cT8_log[0] == 1) x q1[4];\nif(cT8_log[0] == 1) x q1[5];\nif(cT8_log[0] == 1) x q1[6];\n\nif(cT8_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT9_log_raw = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT9_log = cT9_log_raw;\nif(syn_measT9 == 2) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 4) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 6) cT9_log = cT9_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT9_log = cT9_log ^ pf[0];\n\n//Logical X\nif(cT9_log[0] == 1) x q3[4];\nif(cT9_log[0] == 1) x q3[5];\nif(cT9_log[0] == 1) x q3[6];\n\nif(cT9_log[0] == 1) rz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT10[0];\nmeasure q3[1] -> cT10[1];\nmeasure q3[2] -> cT10[2];\nmeasure q3[3] -> cT10[3];\nmeasure q3[4] -> cT10[4];\nmeasure q3[5] -> cT10[5];\nmeasure q3[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT10_log_raw = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT10_log = cT10_log_raw;\nif(syn_measT10 == 2) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 4) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 6) cT10_log = cT10_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT10_log = cT10_log ^ pf[0];\n\n//Logical X\nif(cT10_log[0] == 1) x q1[4];\nif(cT10_log[0] == 1) x q1[5];\nif(cT10_log[0] == 1) x q1[6];\n\nif(cT10_log[0] == 1) rz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q0;\ncx q3[0], q0[0];\ncx q3[1], q0[1];\ncx q3[2], q0[2];\ncx q3[3], q0[3];\ncx q3[4], q0[4];\ncx q3[5], q0[5];\ncx q3[6], q0[6];\nbarrier q3, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT11[0];\nmeasure q0[1] -> cT11[1];\nmeasure q0[2] -> cT11[2];\nmeasure q0[3] -> cT11[3];\nmeasure q0[4] -> cT11[4];\nmeasure q0[5] -> cT11[5];\nmeasure q0[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT11_log_raw = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT11_log = cT11_log_raw;\nif(syn_measT11 == 2) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 4) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 6) cT11_log = cT11_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT11_log = cT11_log ^ pf[0];\n\n//Logical X\nif(cT11_log[0] == 1) x q3[4];\nif(cT11_log[0] == 1) x q3[5];\nif(cT11_log[0] == 1) x q3[6];\n\nif(cT11_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\nbarrier q3;\nbarrier q1;\nbarrier q2;\nrz(pi/2) q1;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q0[6];\nh q0[6];\nrz(pi/4) q0[6];\n\n// Encoding circuit\n// ---------------\nreset q0[0];\nreset q0[1];\nreset q0[2];\nreset q0[3];\nreset q0[4];\nreset q0[5];\n\n// q[6] is the input qubit\n\ncx q0[6],q0[5];\n\nh q0[1];\ncx q0[1], q0[0];\n\nh q0[2];\ncx q0[2], q0[4];\n\n// ---------------\nh q0[3];\ncx q0[3], q0[5];\ncx q0[2], q0[0];\ncx q0[6], q0[4];\n\n// ---------------\ncx q0[2], q0[6];\ncx q0[3], q0[4];\ncx q0[1], q0[5];\n\n// ---------------\ncx q0[1], q0[6];\ncx q0[3], q0[0];\n\n\n// Transversal Logical CX\nbarrier q0, q2;\ncx q0[0], q2[0];\ncx q0[1], q2[1];\ncx q0[2], q2[2];\ncx q0[3], q2[3];\ncx q0[4], q2[4];\ncx q0[5], q2[5];\ncx q0[6], q2[6];\nbarrier q0, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT13[0];\nmeasure q2[1] -> cT13[1];\nmeasure q2[2] -> cT13[2];\nmeasure q2[3] -> cT13[3];\nmeasure q2[4] -> cT13[4];\nmeasure q2[5] -> cT13[5];\nmeasure q2[6] -> cT13[6];\n\n// determine raw logical output\n// ============================\ncT13_log_raw = cT13[4] ^ cT13[5] ^ cT13[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT13[0] = cT13[0] ^ cT13[1] ^ cT13[2] ^ cT13[3];\nsyn_measT13[1] = cT13[1] ^ cT13[2] ^ cT13[4] ^ cT13[5];\nsyn_measT13[2] = cT13[2] ^ cT13[3] ^ cT13[5] ^ cT13[6];\n\n// XOR syndromes\nsyn_measT13 = syn_measT13 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT13_log = cT13_log_raw;\nif(syn_measT13 == 2) cT13_log = cT13_log ^ 1;\nif(syn_measT13 == 4) cT13_log = cT13_log ^ 1;\nif(syn_measT13 == 6) cT13_log = cT13_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT13_log = cT13_log ^ pf[0];\n\n//Logical X\nif(cT13_log[0] == 1) x q0[4];\nif(cT13_log[0] == 1) x q0[5];\nif(cT13_log[0] == 1) x q0[6];\n\nif(cT13_log[0] == 1) rz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Logical H\nh q3;\n// Logical H\nh q1;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c0[0];\nmeasure q3[1] -> c0[1];\nmeasure q3[2] -> c0[2];\nmeasure q3[3] -> c0[3];\nmeasure q3[4] -> c0[4];\nmeasure q3[5] -> c0[5];\nmeasure q3[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c2[0];\nmeasure q0[1] -> c2[1];\nmeasure q0[2] -> c2[2];\nmeasure q0[3] -> c2[3];\nmeasure q0[4] -> c2[4];\nmeasure q0[5] -> c2[5];\nmeasure q0[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];\nc[2] = c2_log[0];"}, "1": {"parameters": ["comp", "000"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg init[4];\ncreg c0[7];\ncreg c1[7];\ncreg c2[7];\ncreg c0_log_raw[7];\ncreg c1_log_raw[7];\ncreg c2_log_raw[7];\ncreg c0_log[7];\ncreg c1_log[7];\ncreg c2_log[7];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\ncreg syn_meas2[3];\ncreg c[3];\ncreg c_mid[7];\ncreg c_mid_log_raw[1];\ncreg c_mid_log[1];\ncreg syn_meas_mid[3];\ncreg cT1[7];\ncreg cT2[7];\ncreg cT3[7];\ncreg cT4[7];\ncreg cT5[7];\ncreg cT6[7];\ncreg cT7[7];\ncreg cT8[7];\ncreg cT9[7];\ncreg cT10[7];\ncreg cT11[7];\ncreg cT12[7];\ncreg cT13[7];\ncreg cT1_log_raw[1];\ncreg cT2_log_raw[1];\ncreg cT3_log_raw[1];\ncreg cT4_log_raw[1];\ncreg cT5_log_raw[1];\ncreg cT6_log_raw[1];\ncreg cT7_log_raw[1];\ncreg cT8_log_raw[1];\ncreg cT9_log_raw[1];\ncreg cT10_log_raw[1];\ncreg cT11_log_raw[1];\ncreg cT12_log_raw[1];\ncreg cT13_log_raw[1];\ncreg cT1_log[1];\ncreg cT2_log[1];\ncreg cT3_log[1];\ncreg cT4_log[1];\ncreg cT5_log[1];\ncreg cT6_log[1];\ncreg cT7_log[1];\ncreg cT8_log[1];\ncreg cT9_log[1];\ncreg cT10_log[1];\ncreg cT11_log[1];\ncreg cT12_log[1];\ncreg cT13_log[1];\ncreg syn_measT1[3];\ncreg syn_measT2[3];\ncreg syn_measT3[3];\ncreg syn_measT4[3];\ncreg syn_measT5[3];\ncreg syn_measT6[3];\ncreg syn_measT7[3];\ncreg syn_measT8[3];\ncreg syn_measT9[3];\ncreg syn_measT10[3];\ncreg syn_measT11[3];\ncreg syn_measT12[3];\ncreg syn_measT13[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n// Logical H\nh q2;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT1_log = cT1_log_raw;\nif(syn_measT1 == 2) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 4) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 6) cT1_log = cT1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT1_log = cT1_log ^ pf[0];\n\n//Logical X\nif(cT1_log[0] == 1) x q3[4];\nif(cT1_log[0] == 1) x q3[5];\nif(cT1_log[0] == 1) x q3[6];\n\nif(cT1_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q1[4];\nif(cT2_log[0] == 1) x q1[5];\nif(cT2_log[0] == 1) x q1[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q1[4];\nif(cT4_log[0] == 1) x q1[5];\nif(cT4_log[0] == 1) x q1[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c_mid[0];\nmeasure q3[1] -> c_mid[1];\nmeasure q3[2] -> c_mid[2];\nmeasure q3[3] -> c_mid[3];\nmeasure q3[4] -> c_mid[4];\nmeasure q3[5] -> c_mid[5];\nmeasure q3[6] -> c_mid[6];\n\n// determine raw logical output\n// ============================\nc_mid_log_raw = c_mid[4] ^ c_mid[5] ^ c_mid[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas_mid[0] = c_mid[0] ^ c_mid[1] ^ c_mid[2] ^ c_mid[3];\nsyn_meas_mid[1] = c_mid[1] ^ c_mid[2] ^ c_mid[4] ^ c_mid[5];\nsyn_meas_mid[2] = c_mid[2] ^ c_mid[3] ^ c_mid[5] ^ c_mid[6];\n\n// XOR syndromes\nsyn_meas_mid = syn_meas_mid ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_mid_log = c_mid_log_raw;\nif(syn_meas_mid == 2) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 4) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 6) c_mid_log = c_mid_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_mid_log = c_mid_log ^ pf[0];\n// Logical H\nif(c_mid_log[0] == 1) h q2;\n\n// Transversal Logical CX\nif(c_mid_log[0] == 1) barrier q0, q2;\nif(c_mid_log[0] == 1) cx q0[0], q2[0];\nif(c_mid_log[0] == 1) cx q0[1], q2[1];\nif(c_mid_log[0] == 1) cx q0[2], q2[2];\nif(c_mid_log[0] == 1) cx q0[3], q2[3];\nif(c_mid_log[0] == 1) cx q0[4], q2[4];\nif(c_mid_log[0] == 1) cx q0[5], q2[5];\nif(c_mid_log[0] == 1) cx q0[6], q2[6];\nif(c_mid_log[0] == 1) barrier q0, q2;\n\n// Logical H\nif(c_mid_log[0] == 1) h q2;\nreset q3;\n\nbarrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nreset q3;\nreset q1[0];\nbarrier q3, q1[0];\n\nh q3[0];\nh q3[4];\nh q3[6];\n\ncx q3[4],q3[5];\ncx q3[0],q3[1];\ncx q3[6],q3[3];\ncx q3[4],q3[2];\ncx q3[6],q3[5];\ncx q3[0],q3[3];\ncx q3[4],q3[1];\ncx q3[3], q3[2];\n\nbarrier q1[0],q3[1],q3[3],q3[5];\n//verification step\ncx q3[5],q1[0];\ncx q3[1],q1[0];\ncx q3[3],q1[0];\nmeasure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q2;\ncx q1[0], q2[0];\ncx q1[1], q2[1];\ncx q1[2], q2[2];\ncx q1[3], q2[3];\ncx q1[4], q2[4];\ncx q1[5], q2[5];\ncx q1[6], q2[6];\nbarrier q1, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT6[0];\nmeasure q2[1] -> cT6[1];\nmeasure q2[2] -> cT6[2];\nmeasure q2[3] -> cT6[3];\nmeasure q2[4] -> cT6[4];\nmeasure q2[5] -> cT6[5];\nmeasure q2[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q1[4];\nif(cT6_log[0] == 1) x q1[5];\nif(cT6_log[0] == 1) x q1[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT7_log_raw = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT7_log = cT7_log_raw;\nif(syn_measT7 == 2) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 4) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 6) cT7_log = cT7_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT7_log = cT7_log ^ pf[0];\n\n//Logical X\nif(cT7_log[0] == 1) x q2[4];\nif(cT7_log[0] == 1) x q2[5];\nif(cT7_log[0] == 1) x q2[6];\n\nif(cT7_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT8[0];\nmeasure q3[1] -> cT8[1];\nmeasure q3[2] -> cT8[2];\nmeasure q3[3] -> cT8[3];\nmeasure q3[4] -> cT8[4];\nmeasure q3[5] -> cT8[5];\nmeasure q3[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT8_log_raw = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT8_log = cT8_log_raw;\nif(syn_measT8 == 2) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 4) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 6) cT8_log = cT8_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT8_log = cT8_log ^ pf[0];\n\n//Logical X\nif(cT8_log[0] == 1) x q1[4];\nif(cT8_log[0] == 1) x q1[5];\nif(cT8_log[0] == 1) x q1[6];\n\nif(cT8_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT9_log_raw = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT9_log = cT9_log_raw;\nif(syn_measT9 == 2) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 4) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 6) cT9_log = cT9_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT9_log = cT9_log ^ pf[0];\n\n//Logical X\nif(cT9_log[0] == 1) x q3[4];\nif(cT9_log[0] == 1) x q3[5];\nif(cT9_log[0] == 1) x q3[6];\n\nif(cT9_log[0] == 1) rz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT10[0];\nmeasure q3[1] -> cT10[1];\nmeasure q3[2] -> cT10[2];\nmeasure q3[3] -> cT10[3];\nmeasure q3[4] -> cT10[4];\nmeasure q3[5] -> cT10[5];\nmeasure q3[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT10_log_raw = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT10_log = cT10_log_raw;\nif(syn_measT10 == 2) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 4) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 6) cT10_log = cT10_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT10_log = cT10_log ^ pf[0];\n\n//Logical X\nif(cT10_log[0] == 1) x q1[4];\nif(cT10_log[0] == 1) x q1[5];\nif(cT10_log[0] == 1) x q1[6];\n\nif(cT10_log[0] == 1) rz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q0;\ncx q3[0], q0[0];\ncx q3[1], q0[1];\ncx q3[2], q0[2];\ncx q3[3], q0[3];\ncx q3[4], q0[4];\ncx q3[5], q0[5];\ncx q3[6], q0[6];\nbarrier q3, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT11[0];\nmeasure q0[1] -> cT11[1];\nmeasure q0[2] -> cT11[2];\nmeasure q0[3] -> cT11[3];\nmeasure q0[4] -> cT11[4];\nmeasure q0[5] -> cT11[5];\nmeasure q0[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT11_log_raw = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT11_log = cT11_log_raw;\nif(syn_measT11 == 2) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 4) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 6) cT11_log = cT11_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT11_log = cT11_log ^ pf[0];\n\n//Logical X\nif(cT11_log[0] == 1) x q3[4];\nif(cT11_log[0] == 1) x q3[5];\nif(cT11_log[0] == 1) x q3[6];\n\nif(cT11_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\nbarrier q3;\nbarrier q1;\nbarrier q2;\n// Logical H\nh q3;\n// Logical H\nh q1;\n// Logical H\nh q2;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c0[0];\nmeasure q3[1] -> c0[1];\nmeasure q3[2] -> c0[2];\nmeasure q3[3] -> c0[3];\nmeasure q3[4] -> c0[4];\nmeasure q3[5] -> c0[5];\nmeasure q3[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> c2[0];\nmeasure q2[1] -> c2[1];\nmeasure q2[2] -> c2[2];\nmeasure q2[3] -> c2[3];\nmeasure q2[4] -> c2[4];\nmeasure q2[5] -> c2[5];\nmeasure q2[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];\nc[2] = c2_log[0];"}, "2": {"parameters": ["fourier", "010"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg init[4];\ncreg c0[7];\ncreg c1[7];\ncreg c2[7];\ncreg c0_log_raw[7];\ncreg c1_log_raw[7];\ncreg c2_log_raw[7];\ncreg c0_log[7];\ncreg c1_log[7];\ncreg c2_log[7];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\ncreg syn_meas2[3];\ncreg c[3];\ncreg c_mid[7];\ncreg c_mid_log_raw[1];\ncreg c_mid_log[1];\ncreg syn_meas_mid[3];\ncreg cT1[7];\ncreg cT2[7];\ncreg cT3[7];\ncreg cT4[7];\ncreg cT5[7];\ncreg cT6[7];\ncreg cT7[7];\ncreg cT8[7];\ncreg cT9[7];\ncreg cT10[7];\ncreg cT11[7];\ncreg cT12[7];\ncreg cT13[7];\ncreg cT1_log_raw[1];\ncreg cT2_log_raw[1];\ncreg cT3_log_raw[1];\ncreg cT4_log_raw[1];\ncreg cT5_log_raw[1];\ncreg cT6_log_raw[1];\ncreg cT7_log_raw[1];\ncreg cT8_log_raw[1];\ncreg cT9_log_raw[1];\ncreg cT10_log_raw[1];\ncreg cT11_log_raw[1];\ncreg cT12_log_raw[1];\ncreg cT13_log_raw[1];\ncreg cT1_log[1];\ncreg cT2_log[1];\ncreg cT3_log[1];\ncreg cT4_log[1];\ncreg cT5_log[1];\ncreg cT6_log[1];\ncreg cT7_log[1];\ncreg cT8_log[1];\ncreg cT9_log[1];\ncreg cT10_log[1];\ncreg cT11_log[1];\ncreg cT12_log[1];\ncreg cT13_log[1];\ncreg syn_measT1[3];\ncreg syn_measT2[3];\ncreg syn_measT3[3];\ncreg syn_measT4[3];\ncreg syn_measT5[3];\ncreg syn_measT6[3];\ncreg syn_measT7[3];\ncreg syn_measT8[3];\ncreg syn_measT9[3];\ncreg syn_measT10[3];\ncreg syn_measT11[3];\ncreg syn_measT12[3];\ncreg syn_measT13[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n// Logical H\nh q0;\n// Logical H\nh q2;\nrz(pi/2) q0;\n// Logical H\nh q2;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT1_log = cT1_log_raw;\nif(syn_measT1 == 2) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 4) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 6) cT1_log = cT1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT1_log = cT1_log ^ pf[0];\n\n//Logical X\nif(cT1_log[0] == 1) x q3[4];\nif(cT1_log[0] == 1) x q3[5];\nif(cT1_log[0] == 1) x q3[6];\n\nif(cT1_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q1[4];\nif(cT2_log[0] == 1) x q1[5];\nif(cT2_log[0] == 1) x q1[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q1[4];\nif(cT4_log[0] == 1) x q1[5];\nif(cT4_log[0] == 1) x q1[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c_mid[0];\nmeasure q3[1] -> c_mid[1];\nmeasure q3[2] -> c_mid[2];\nmeasure q3[3] -> c_mid[3];\nmeasure q3[4] -> c_mid[4];\nmeasure q3[5] -> c_mid[5];\nmeasure q3[6] -> c_mid[6];\n\n// determine raw logical output\n// ============================\nc_mid_log_raw = c_mid[4] ^ c_mid[5] ^ c_mid[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas_mid[0] = c_mid[0] ^ c_mid[1] ^ c_mid[2] ^ c_mid[3];\nsyn_meas_mid[1] = c_mid[1] ^ c_mid[2] ^ c_mid[4] ^ c_mid[5];\nsyn_meas_mid[2] = c_mid[2] ^ c_mid[3] ^ c_mid[5] ^ c_mid[6];\n\n// XOR syndromes\nsyn_meas_mid = syn_meas_mid ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_mid_log = c_mid_log_raw;\nif(syn_meas_mid == 2) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 4) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 6) c_mid_log = c_mid_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_mid_log = c_mid_log ^ pf[0];\n// Logical H\nif(c_mid_log[0] == 1) h q2;\n\n// Transversal Logical CX\nif(c_mid_log[0] == 1) barrier q0, q2;\nif(c_mid_log[0] == 1) cx q0[0], q2[0];\nif(c_mid_log[0] == 1) cx q0[1], q2[1];\nif(c_mid_log[0] == 1) cx q0[2], q2[2];\nif(c_mid_log[0] == 1) cx q0[3], q2[3];\nif(c_mid_log[0] == 1) cx q0[4], q2[4];\nif(c_mid_log[0] == 1) cx q0[5], q2[5];\nif(c_mid_log[0] == 1) cx q0[6], q2[6];\nif(c_mid_log[0] == 1) barrier q0, q2;\n\n// Logical H\nif(c_mid_log[0] == 1) h q2;\nreset q3;\n\nbarrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nreset q3;\nreset q1[0];\nbarrier q3, q1[0];\n\nh q3[0];\nh q3[4];\nh q3[6];\n\ncx q3[4],q3[5];\ncx q3[0],q3[1];\ncx q3[6],q3[3];\ncx q3[4],q3[2];\ncx q3[6],q3[5];\ncx q3[0],q3[3];\ncx q3[4],q3[1];\ncx q3[3], q3[2];\n\nbarrier q1[0],q3[1],q3[3],q3[5];\n//verification step\ncx q3[5],q1[0];\ncx q3[1],q1[0];\ncx q3[3],q1[0];\nmeasure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\n// Logical H\nh q3;\n\n//Logical Z\nz q3[4];\nz q3[5];\nz q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q2;\ncx q1[0], q2[0];\ncx q1[1], q2[1];\ncx q1[2], q2[2];\ncx q1[3], q2[3];\ncx q1[4], q2[4];\ncx q1[5], q2[5];\ncx q1[6], q2[6];\nbarrier q1, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT6[0];\nmeasure q2[1] -> cT6[1];\nmeasure q2[2] -> cT6[2];\nmeasure q2[3] -> cT6[3];\nmeasure q2[4] -> cT6[4];\nmeasure q2[5] -> cT6[5];\nmeasure q2[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q1[4];\nif(cT6_log[0] == 1) x q1[5];\nif(cT6_log[0] == 1) x q1[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT7_log_raw = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT7_log = cT7_log_raw;\nif(syn_measT7 == 2) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 4) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 6) cT7_log = cT7_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT7_log = cT7_log ^ pf[0];\n\n//Logical X\nif(cT7_log[0] == 1) x q2[4];\nif(cT7_log[0] == 1) x q2[5];\nif(cT7_log[0] == 1) x q2[6];\n\nif(cT7_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT8[0];\nmeasure q3[1] -> cT8[1];\nmeasure q3[2] -> cT8[2];\nmeasure q3[3] -> cT8[3];\nmeasure q3[4] -> cT8[4];\nmeasure q3[5] -> cT8[5];\nmeasure q3[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT8_log_raw = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT8_log = cT8_log_raw;\nif(syn_measT8 == 2) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 4) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 6) cT8_log = cT8_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT8_log = cT8_log ^ pf[0];\n\n//Logical X\nif(cT8_log[0] == 1) x q1[4];\nif(cT8_log[0] == 1) x q1[5];\nif(cT8_log[0] == 1) x q1[6];\n\nif(cT8_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT9_log_raw = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT9_log = cT9_log_raw;\nif(syn_measT9 == 2) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 4) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 6) cT9_log = cT9_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT9_log = cT9_log ^ pf[0];\n\n//Logical X\nif(cT9_log[0] == 1) x q3[4];\nif(cT9_log[0] == 1) x q3[5];\nif(cT9_log[0] == 1) x q3[6];\n\nif(cT9_log[0] == 1) rz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT10[0];\nmeasure q3[1] -> cT10[1];\nmeasure q3[2] -> cT10[2];\nmeasure q3[3] -> cT10[3];\nmeasure q3[4] -> cT10[4];\nmeasure q3[5] -> cT10[5];\nmeasure q3[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT10_log_raw = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT10_log = cT10_log_raw;\nif(syn_measT10 == 2) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 4) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 6) cT10_log = cT10_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT10_log = cT10_log ^ pf[0];\n\n//Logical X\nif(cT10_log[0] == 1) x q1[4];\nif(cT10_log[0] == 1) x q1[5];\nif(cT10_log[0] == 1) x q1[6];\n\nif(cT10_log[0] == 1) rz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q0;\ncx q3[0], q0[0];\ncx q3[1], q0[1];\ncx q3[2], q0[2];\ncx q3[3], q0[3];\ncx q3[4], q0[4];\ncx q3[5], q0[5];\ncx q3[6], q0[6];\nbarrier q3, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT11[0];\nmeasure q0[1] -> cT11[1];\nmeasure q0[2] -> cT11[2];\nmeasure q0[3] -> cT11[3];\nmeasure q0[4] -> cT11[4];\nmeasure q0[5] -> cT11[5];\nmeasure q0[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT11_log_raw = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT11_log = cT11_log_raw;\nif(syn_measT11 == 2) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 4) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 6) cT11_log = cT11_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT11_log = cT11_log ^ pf[0];\n\n//Logical X\nif(cT11_log[0] == 1) x q3[4];\nif(cT11_log[0] == 1) x q3[5];\nif(cT11_log[0] == 1) x q3[6];\n\nif(cT11_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\nbarrier q3;\nbarrier q1;\nbarrier q2;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c0[0];\nmeasure q3[1] -> c0[1];\nmeasure q3[2] -> c0[2];\nmeasure q3[3] -> c0[3];\nmeasure q3[4] -> c0[4];\nmeasure q3[5] -> c0[5];\nmeasure q3[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> c2[0];\nmeasure q2[1] -> c2[1];\nmeasure q2[2] -> c2[2];\nmeasure q2[3] -> c2[3];\nmeasure q2[4] -> c2[4];\nmeasure q2[5] -> c2[5];\nmeasure q2[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];\nc[2] = c2_log[0];"}, "3": {"parameters": ["fourier", "111"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg init[4];\ncreg c0[7];\ncreg c1[7];\ncreg c2[7];\ncreg c0_log_raw[7];\ncreg c1_log_raw[7];\ncreg c2_log_raw[7];\ncreg c0_log[7];\ncreg c1_log[7];\ncreg c2_log[7];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\ncreg syn_meas2[3];\ncreg c[3];\ncreg c_mid[7];\ncreg c_mid_log_raw[1];\ncreg c_mid_log[1];\ncreg syn_meas_mid[3];\ncreg cT1[7];\ncreg cT2[7];\ncreg cT3[7];\ncreg cT4[7];\ncreg cT5[7];\ncreg cT6[7];\ncreg cT7[7];\ncreg cT8[7];\ncreg cT9[7];\ncreg cT10[7];\ncreg cT11[7];\ncreg cT12[7];\ncreg cT13[7];\ncreg cT1_log_raw[1];\ncreg cT2_log_raw[1];\ncreg cT3_log_raw[1];\ncreg cT4_log_raw[1];\ncreg cT5_log_raw[1];\ncreg cT6_log_raw[1];\ncreg cT7_log_raw[1];\ncreg cT8_log_raw[1];\ncreg cT9_log_raw[1];\ncreg cT10_log_raw[1];\ncreg cT11_log_raw[1];\ncreg cT12_log_raw[1];\ncreg cT13_log_raw[1];\ncreg cT1_log[1];\ncreg cT2_log[1];\ncreg cT3_log[1];\ncreg cT4_log[1];\ncreg cT5_log[1];\ncreg cT6_log[1];\ncreg cT7_log[1];\ncreg cT8_log[1];\ncreg cT9_log[1];\ncreg cT10_log[1];\ncreg cT11_log[1];\ncreg cT12_log[1];\ncreg cT13_log[1];\ncreg syn_measT1[3];\ncreg syn_measT2[3];\ncreg syn_measT3[3];\ncreg syn_measT4[3];\ncreg syn_measT5[3];\ncreg syn_measT6[3];\ncreg syn_measT7[3];\ncreg syn_measT8[3];\ncreg syn_measT9[3];\ncreg syn_measT10[3];\ncreg syn_measT11[3];\ncreg syn_measT12[3];\ncreg syn_measT13[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n// Logical H\nh q0;\n// Logical H\nh q2;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT12[0];\nmeasure q3[1] -> cT12[1];\nmeasure q3[2] -> cT12[2];\nmeasure q3[3] -> cT12[3];\nmeasure q3[4] -> cT12[4];\nmeasure q3[5] -> cT12[5];\nmeasure q3[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT12_log_raw = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT12_log = cT12_log_raw;\nif(syn_measT12 == 2) cT12_log = cT12_log ^ 1;\nif(syn_measT12 == 4) cT12_log = cT12_log ^ 1;\nif(syn_measT12 == 6) cT12_log = cT12_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT12_log = cT12_log ^ pf[0];\nif(cT12_log[0] == 1) rz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical Z\nz q2[4];\nz q2[5];\nz q2[6];\n\n// Logical H\nh q2;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT1_log = cT1_log_raw;\nif(syn_measT1 == 2) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 4) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 6) cT1_log = cT1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT1_log = cT1_log ^ pf[0];\n\n//Logical X\nif(cT1_log[0] == 1) x q3[4];\nif(cT1_log[0] == 1) x q3[5];\nif(cT1_log[0] == 1) x q3[6];\n\nif(cT1_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q1[4];\nif(cT2_log[0] == 1) x q1[5];\nif(cT2_log[0] == 1) x q1[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q1[4];\nif(cT4_log[0] == 1) x q1[5];\nif(cT4_log[0] == 1) x q1[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c_mid[0];\nmeasure q3[1] -> c_mid[1];\nmeasure q3[2] -> c_mid[2];\nmeasure q3[3] -> c_mid[3];\nmeasure q3[4] -> c_mid[4];\nmeasure q3[5] -> c_mid[5];\nmeasure q3[6] -> c_mid[6];\n\n// determine raw logical output\n// ============================\nc_mid_log_raw = c_mid[4] ^ c_mid[5] ^ c_mid[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas_mid[0] = c_mid[0] ^ c_mid[1] ^ c_mid[2] ^ c_mid[3];\nsyn_meas_mid[1] = c_mid[1] ^ c_mid[2] ^ c_mid[4] ^ c_mid[5];\nsyn_meas_mid[2] = c_mid[2] ^ c_mid[3] ^ c_mid[5] ^ c_mid[6];\n\n// XOR syndromes\nsyn_meas_mid = syn_meas_mid ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_mid_log = c_mid_log_raw;\nif(syn_meas_mid == 2) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 4) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 6) c_mid_log = c_mid_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_mid_log = c_mid_log ^ pf[0];\n// Logical H\nif(c_mid_log[0] == 1) h q2;\n\n// Transversal Logical CX\nif(c_mid_log[0] == 1) barrier q0, q2;\nif(c_mid_log[0] == 1) cx q0[0], q2[0];\nif(c_mid_log[0] == 1) cx q0[1], q2[1];\nif(c_mid_log[0] == 1) cx q0[2], q2[2];\nif(c_mid_log[0] == 1) cx q0[3], q2[3];\nif(c_mid_log[0] == 1) cx q0[4], q2[4];\nif(c_mid_log[0] == 1) cx q0[5], q2[5];\nif(c_mid_log[0] == 1) cx q0[6], q2[6];\nif(c_mid_log[0] == 1) barrier q0, q2;\n\n// Logical H\nif(c_mid_log[0] == 1) h q2;\nreset q3;\n\nbarrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nreset q3;\nreset q1[0];\nbarrier q3, q1[0];\n\nh q3[0];\nh q3[4];\nh q3[6];\n\ncx q3[4],q3[5];\ncx q3[0],q3[1];\ncx q3[6],q3[3];\ncx q3[4],q3[2];\ncx q3[6],q3[5];\ncx q3[0],q3[3];\ncx q3[4],q3[1];\ncx q3[3], q3[2];\n\nbarrier q1[0],q3[1],q3[3],q3[5];\n//verification step\ncx q3[5],q1[0];\ncx q3[1],q1[0];\ncx q3[3],q1[0];\nmeasure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\n// Logical H\nh q3;\n\n//Logical Z\nz q3[4];\nz q3[5];\nz q3[6];\n\nrz(pi/2) q3;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q2;\ncx q1[0], q2[0];\ncx q1[1], q2[1];\ncx q1[2], q2[2];\ncx q1[3], q2[3];\ncx q1[4], q2[4];\ncx q1[5], q2[5];\ncx q1[6], q2[6];\nbarrier q1, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT6[0];\nmeasure q2[1] -> cT6[1];\nmeasure q2[2] -> cT6[2];\nmeasure q2[3] -> cT6[3];\nmeasure q2[4] -> cT6[4];\nmeasure q2[5] -> cT6[5];\nmeasure q2[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q1[4];\nif(cT6_log[0] == 1) x q1[5];\nif(cT6_log[0] == 1) x q1[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT7_log_raw = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT7_log = cT7_log_raw;\nif(syn_measT7 == 2) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 4) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 6) cT7_log = cT7_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT7_log = cT7_log ^ pf[0];\n\n//Logical X\nif(cT7_log[0] == 1) x q2[4];\nif(cT7_log[0] == 1) x q2[5];\nif(cT7_log[0] == 1) x q2[6];\n\nif(cT7_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT8[0];\nmeasure q3[1] -> cT8[1];\nmeasure q3[2] -> cT8[2];\nmeasure q3[3] -> cT8[3];\nmeasure q3[4] -> cT8[4];\nmeasure q3[5] -> cT8[5];\nmeasure q3[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT8_log_raw = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT8_log = cT8_log_raw;\nif(syn_measT8 == 2) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 4) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 6) cT8_log = cT8_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT8_log = cT8_log ^ pf[0];\n\n//Logical X\nif(cT8_log[0] == 1) x q1[4];\nif(cT8_log[0] == 1) x q1[5];\nif(cT8_log[0] == 1) x q1[6];\n\nif(cT8_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT9_log_raw = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT9_log = cT9_log_raw;\nif(syn_measT9 == 2) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 4) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 6) cT9_log = cT9_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT9_log = cT9_log ^ pf[0];\n\n//Logical X\nif(cT9_log[0] == 1) x q3[4];\nif(cT9_log[0] == 1) x q3[5];\nif(cT9_log[0] == 1) x q3[6];\n\nif(cT9_log[0] == 1) rz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT10[0];\nmeasure q3[1] -> cT10[1];\nmeasure q3[2] -> cT10[2];\nmeasure q3[3] -> cT10[3];\nmeasure q3[4] -> cT10[4];\nmeasure q3[5] -> cT10[5];\nmeasure q3[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT10_log_raw = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT10_log = cT10_log_raw;\nif(syn_measT10 == 2) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 4) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 6) cT10_log = cT10_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT10_log = cT10_log ^ pf[0];\n\n//Logical X\nif(cT10_log[0] == 1) x q1[4];\nif(cT10_log[0] == 1) x q1[5];\nif(cT10_log[0] == 1) x q1[6];\n\nif(cT10_log[0] == 1) rz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q0;\ncx q3[0], q0[0];\ncx q3[1], q0[1];\ncx q3[2], q0[2];\ncx q3[3], q0[3];\ncx q3[4], q0[4];\ncx q3[5], q0[5];\ncx q3[6], q0[6];\nbarrier q3, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT11[0];\nmeasure q0[1] -> cT11[1];\nmeasure q0[2] -> cT11[2];\nmeasure q0[3] -> cT11[3];\nmeasure q0[4] -> cT11[4];\nmeasure q0[5] -> cT11[5];\nmeasure q0[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT11_log_raw = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT11_log = cT11_log_raw;\nif(syn_measT11 == 2) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 4) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 6) cT11_log = cT11_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT11_log = cT11_log ^ pf[0];\n\n//Logical X\nif(cT11_log[0] == 1) x q3[4];\nif(cT11_log[0] == 1) x q3[5];\nif(cT11_log[0] == 1) x q3[6];\n\nif(cT11_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\nbarrier q3;\nbarrier q1;\nbarrier q2;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c0[0];\nmeasure q3[1] -> c0[1];\nmeasure q3[2] -> c0[2];\nmeasure q3[3] -> c0[3];\nmeasure q3[4] -> c0[4];\nmeasure q3[5] -> c0[5];\nmeasure q3[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> c2[0];\nmeasure q2[1] -> c2[1];\nmeasure q2[2] -> c2[2];\nmeasure q2[3] -> c2[3];\nmeasure q2[4] -> c2[4];\nmeasure q2[5] -> c2[5];\nmeasure q2[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];\nc[2] = c2_log[0];"}, "4": {"parameters": ["comp", "010"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg init[4];\ncreg c0[7];\ncreg c1[7];\ncreg c2[7];\ncreg c0_log_raw[7];\ncreg c1_log_raw[7];\ncreg c2_log_raw[7];\ncreg c0_log[7];\ncreg c1_log[7];\ncreg c2_log[7];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\ncreg syn_meas2[3];\ncreg c[3];\ncreg c_mid[7];\ncreg c_mid_log_raw[1];\ncreg c_mid_log[1];\ncreg syn_meas_mid[3];\ncreg cT1[7];\ncreg cT2[7];\ncreg cT3[7];\ncreg cT4[7];\ncreg cT5[7];\ncreg cT6[7];\ncreg cT7[7];\ncreg cT8[7];\ncreg cT9[7];\ncreg cT10[7];\ncreg cT11[7];\ncreg cT12[7];\ncreg cT13[7];\ncreg cT1_log_raw[1];\ncreg cT2_log_raw[1];\ncreg cT3_log_raw[1];\ncreg cT4_log_raw[1];\ncreg cT5_log_raw[1];\ncreg cT6_log_raw[1];\ncreg cT7_log_raw[1];\ncreg cT8_log_raw[1];\ncreg cT9_log_raw[1];\ncreg cT10_log_raw[1];\ncreg cT11_log_raw[1];\ncreg cT12_log_raw[1];\ncreg cT13_log_raw[1];\ncreg cT1_log[1];\ncreg cT2_log[1];\ncreg cT3_log[1];\ncreg cT4_log[1];\ncreg cT5_log[1];\ncreg cT6_log[1];\ncreg cT7_log[1];\ncreg cT8_log[1];\ncreg cT9_log[1];\ncreg cT10_log[1];\ncreg cT11_log[1];\ncreg cT12_log[1];\ncreg cT13_log[1];\ncreg syn_measT1[3];\ncreg syn_measT2[3];\ncreg syn_measT3[3];\ncreg syn_measT4[3];\ncreg syn_measT5[3];\ncreg syn_measT6[3];\ncreg syn_measT7[3];\ncreg syn_measT8[3];\ncreg syn_measT9[3];\ncreg syn_measT10[3];\ncreg syn_measT11[3];\ncreg syn_measT12[3];\ncreg syn_measT13[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n// Logical H\nh q2;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT1_log = cT1_log_raw;\nif(syn_measT1 == 2) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 4) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 6) cT1_log = cT1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT1_log = cT1_log ^ pf[0];\n\n//Logical X\nif(cT1_log[0] == 1) x q3[4];\nif(cT1_log[0] == 1) x q3[5];\nif(cT1_log[0] == 1) x q3[6];\n\nif(cT1_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q1[4];\nif(cT2_log[0] == 1) x q1[5];\nif(cT2_log[0] == 1) x q1[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q1[4];\nif(cT4_log[0] == 1) x q1[5];\nif(cT4_log[0] == 1) x q1[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c_mid[0];\nmeasure q3[1] -> c_mid[1];\nmeasure q3[2] -> c_mid[2];\nmeasure q3[3] -> c_mid[3];\nmeasure q3[4] -> c_mid[4];\nmeasure q3[5] -> c_mid[5];\nmeasure q3[6] -> c_mid[6];\n\n// determine raw logical output\n// ============================\nc_mid_log_raw = c_mid[4] ^ c_mid[5] ^ c_mid[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas_mid[0] = c_mid[0] ^ c_mid[1] ^ c_mid[2] ^ c_mid[3];\nsyn_meas_mid[1] = c_mid[1] ^ c_mid[2] ^ c_mid[4] ^ c_mid[5];\nsyn_meas_mid[2] = c_mid[2] ^ c_mid[3] ^ c_mid[5] ^ c_mid[6];\n\n// XOR syndromes\nsyn_meas_mid = syn_meas_mid ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_mid_log = c_mid_log_raw;\nif(syn_meas_mid == 2) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 4) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 6) c_mid_log = c_mid_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_mid_log = c_mid_log ^ pf[0];\n// Logical H\nif(c_mid_log[0] == 1) h q2;\n\n// Transversal Logical CX\nif(c_mid_log[0] == 1) barrier q0, q2;\nif(c_mid_log[0] == 1) cx q0[0], q2[0];\nif(c_mid_log[0] == 1) cx q0[1], q2[1];\nif(c_mid_log[0] == 1) cx q0[2], q2[2];\nif(c_mid_log[0] == 1) cx q0[3], q2[3];\nif(c_mid_log[0] == 1) cx q0[4], q2[4];\nif(c_mid_log[0] == 1) cx q0[5], q2[5];\nif(c_mid_log[0] == 1) cx q0[6], q2[6];\nif(c_mid_log[0] == 1) barrier q0, q2;\n\n// Logical H\nif(c_mid_log[0] == 1) h q2;\nreset q3;\n\nbarrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nreset q3;\nreset q1[0];\nbarrier q3, q1[0];\n\nh q3[0];\nh q3[4];\nh q3[6];\n\ncx q3[4],q3[5];\ncx q3[0],q3[1];\ncx q3[6],q3[3];\ncx q3[4],q3[2];\ncx q3[6],q3[5];\ncx q3[0],q3[3];\ncx q3[4],q3[1];\ncx q3[3], q3[2];\n\nbarrier q1[0],q3[1],q3[3],q3[5];\n//verification step\ncx q3[5],q1[0];\ncx q3[1],q1[0];\ncx q3[3],q1[0];\nmeasure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q2;\ncx q1[0], q2[0];\ncx q1[1], q2[1];\ncx q1[2], q2[2];\ncx q1[3], q2[3];\ncx q1[4], q2[4];\ncx q1[5], q2[5];\ncx q1[6], q2[6];\nbarrier q1, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT6[0];\nmeasure q2[1] -> cT6[1];\nmeasure q2[2] -> cT6[2];\nmeasure q2[3] -> cT6[3];\nmeasure q2[4] -> cT6[4];\nmeasure q2[5] -> cT6[5];\nmeasure q2[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q1[4];\nif(cT6_log[0] == 1) x q1[5];\nif(cT6_log[0] == 1) x q1[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT7_log_raw = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT7_log = cT7_log_raw;\nif(syn_measT7 == 2) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 4) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 6) cT7_log = cT7_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT7_log = cT7_log ^ pf[0];\n\n//Logical X\nif(cT7_log[0] == 1) x q2[4];\nif(cT7_log[0] == 1) x q2[5];\nif(cT7_log[0] == 1) x q2[6];\n\nif(cT7_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT8[0];\nmeasure q3[1] -> cT8[1];\nmeasure q3[2] -> cT8[2];\nmeasure q3[3] -> cT8[3];\nmeasure q3[4] -> cT8[4];\nmeasure q3[5] -> cT8[5];\nmeasure q3[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT8_log_raw = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT8_log = cT8_log_raw;\nif(syn_measT8 == 2) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 4) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 6) cT8_log = cT8_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT8_log = cT8_log ^ pf[0];\n\n//Logical X\nif(cT8_log[0] == 1) x q1[4];\nif(cT8_log[0] == 1) x q1[5];\nif(cT8_log[0] == 1) x q1[6];\n\nif(cT8_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT9_log_raw = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT9_log = cT9_log_raw;\nif(syn_measT9 == 2) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 4) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 6) cT9_log = cT9_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT9_log = cT9_log ^ pf[0];\n\n//Logical X\nif(cT9_log[0] == 1) x q3[4];\nif(cT9_log[0] == 1) x q3[5];\nif(cT9_log[0] == 1) x q3[6];\n\nif(cT9_log[0] == 1) rz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT10[0];\nmeasure q3[1] -> cT10[1];\nmeasure q3[2] -> cT10[2];\nmeasure q3[3] -> cT10[3];\nmeasure q3[4] -> cT10[4];\nmeasure q3[5] -> cT10[5];\nmeasure q3[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT10_log_raw = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT10_log = cT10_log_raw;\nif(syn_measT10 == 2) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 4) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 6) cT10_log = cT10_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT10_log = cT10_log ^ pf[0];\n\n//Logical X\nif(cT10_log[0] == 1) x q1[4];\nif(cT10_log[0] == 1) x q1[5];\nif(cT10_log[0] == 1) x q1[6];\n\nif(cT10_log[0] == 1) rz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q0;\ncx q3[0], q0[0];\ncx q3[1], q0[1];\ncx q3[2], q0[2];\ncx q3[3], q0[3];\ncx q3[4], q0[4];\ncx q3[5], q0[5];\ncx q3[6], q0[6];\nbarrier q3, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT11[0];\nmeasure q0[1] -> cT11[1];\nmeasure q0[2] -> cT11[2];\nmeasure q0[3] -> cT11[3];\nmeasure q0[4] -> cT11[4];\nmeasure q0[5] -> cT11[5];\nmeasure q0[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT11_log_raw = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT11_log = cT11_log_raw;\nif(syn_measT11 == 2) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 4) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 6) cT11_log = cT11_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT11_log = cT11_log ^ pf[0];\n\n//Logical X\nif(cT11_log[0] == 1) x q3[4];\nif(cT11_log[0] == 1) x q3[5];\nif(cT11_log[0] == 1) x q3[6];\n\nif(cT11_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\nbarrier q3;\nbarrier q1;\nbarrier q2;\nrz(pi/2) q2;\n// Logical H\nh q3;\n// Logical H\nh q1;\n// Logical H\nh q2;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c0[0];\nmeasure q3[1] -> c0[1];\nmeasure q3[2] -> c0[2];\nmeasure q3[3] -> c0[3];\nmeasure q3[4] -> c0[4];\nmeasure q3[5] -> c0[5];\nmeasure q3[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> c2[0];\nmeasure q2[1] -> c2[1];\nmeasure q2[2] -> c2[2];\nmeasure q2[3] -> c2[3];\nmeasure q2[4] -> c2[4];\nmeasure q2[5] -> c2[5];\nmeasure q2[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];\nc[2] = c2_log[0];"}, "5": {"parameters": ["fourier", "011"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg init[4];\ncreg c0[7];\ncreg c1[7];\ncreg c2[7];\ncreg c0_log_raw[7];\ncreg c1_log_raw[7];\ncreg c2_log_raw[7];\ncreg c0_log[7];\ncreg c1_log[7];\ncreg c2_log[7];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\ncreg syn_meas2[3];\ncreg c[3];\ncreg c_mid[7];\ncreg c_mid_log_raw[1];\ncreg c_mid_log[1];\ncreg syn_meas_mid[3];\ncreg cT1[7];\ncreg cT2[7];\ncreg cT3[7];\ncreg cT4[7];\ncreg cT5[7];\ncreg cT6[7];\ncreg cT7[7];\ncreg cT8[7];\ncreg cT9[7];\ncreg cT10[7];\ncreg cT11[7];\ncreg cT12[7];\ncreg cT13[7];\ncreg cT1_log_raw[1];\ncreg cT2_log_raw[1];\ncreg cT3_log_raw[1];\ncreg cT4_log_raw[1];\ncreg cT5_log_raw[1];\ncreg cT6_log_raw[1];\ncreg cT7_log_raw[1];\ncreg cT8_log_raw[1];\ncreg cT9_log_raw[1];\ncreg cT10_log_raw[1];\ncreg cT11_log_raw[1];\ncreg cT12_log_raw[1];\ncreg cT13_log_raw[1];\ncreg cT1_log[1];\ncreg cT2_log[1];\ncreg cT3_log[1];\ncreg cT4_log[1];\ncreg cT5_log[1];\ncreg cT6_log[1];\ncreg cT7_log[1];\ncreg cT8_log[1];\ncreg cT9_log[1];\ncreg cT10_log[1];\ncreg cT11_log[1];\ncreg cT12_log[1];\ncreg cT13_log[1];\ncreg syn_measT1[3];\ncreg syn_measT2[3];\ncreg syn_measT3[3];\ncreg syn_measT4[3];\ncreg syn_measT5[3];\ncreg syn_measT6[3];\ncreg syn_measT7[3];\ncreg syn_measT8[3];\ncreg syn_measT9[3];\ncreg syn_measT10[3];\ncreg syn_measT11[3];\ncreg syn_measT12[3];\ncreg syn_measT13[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n// Logical H\nh q0;\n// Logical H\nh q2;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\nrz(pi/2) q0;\n// Logical H\nh q2;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT1_log = cT1_log_raw;\nif(syn_measT1 == 2) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 4) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 6) cT1_log = cT1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT1_log = cT1_log ^ pf[0];\n\n//Logical X\nif(cT1_log[0] == 1) x q3[4];\nif(cT1_log[0] == 1) x q3[5];\nif(cT1_log[0] == 1) x q3[6];\n\nif(cT1_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q1[4];\nif(cT2_log[0] == 1) x q1[5];\nif(cT2_log[0] == 1) x q1[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q1[4];\nif(cT4_log[0] == 1) x q1[5];\nif(cT4_log[0] == 1) x q1[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c_mid[0];\nmeasure q3[1] -> c_mid[1];\nmeasure q3[2] -> c_mid[2];\nmeasure q3[3] -> c_mid[3];\nmeasure q3[4] -> c_mid[4];\nmeasure q3[5] -> c_mid[5];\nmeasure q3[6] -> c_mid[6];\n\n// determine raw logical output\n// ============================\nc_mid_log_raw = c_mid[4] ^ c_mid[5] ^ c_mid[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas_mid[0] = c_mid[0] ^ c_mid[1] ^ c_mid[2] ^ c_mid[3];\nsyn_meas_mid[1] = c_mid[1] ^ c_mid[2] ^ c_mid[4] ^ c_mid[5];\nsyn_meas_mid[2] = c_mid[2] ^ c_mid[3] ^ c_mid[5] ^ c_mid[6];\n\n// XOR syndromes\nsyn_meas_mid = syn_meas_mid ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_mid_log = c_mid_log_raw;\nif(syn_meas_mid == 2) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 4) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 6) c_mid_log = c_mid_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_mid_log = c_mid_log ^ pf[0];\n// Logical H\nif(c_mid_log[0] == 1) h q2;\n\n// Transversal Logical CX\nif(c_mid_log[0] == 1) barrier q0, q2;\nif(c_mid_log[0] == 1) cx q0[0], q2[0];\nif(c_mid_log[0] == 1) cx q0[1], q2[1];\nif(c_mid_log[0] == 1) cx q0[2], q2[2];\nif(c_mid_log[0] == 1) cx q0[3], q2[3];\nif(c_mid_log[0] == 1) cx q0[4], q2[4];\nif(c_mid_log[0] == 1) cx q0[5], q2[5];\nif(c_mid_log[0] == 1) cx q0[6], q2[6];\nif(c_mid_log[0] == 1) barrier q0, q2;\n\n// Logical H\nif(c_mid_log[0] == 1) h q2;\nreset q3;\n\nbarrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nreset q3;\nreset q1[0];\nbarrier q3, q1[0];\n\nh q3[0];\nh q3[4];\nh q3[6];\n\ncx q3[4],q3[5];\ncx q3[0],q3[1];\ncx q3[6],q3[3];\ncx q3[4],q3[2];\ncx q3[6],q3[5];\ncx q3[0],q3[3];\ncx q3[4],q3[1];\ncx q3[3], q3[2];\n\nbarrier q1[0],q3[1],q3[3],q3[5];\n//verification step\ncx q3[5],q1[0];\ncx q3[1],q1[0];\ncx q3[3],q1[0];\nmeasure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\n// Logical H\nh q3;\n\n//Logical Z\nz q3[4];\nz q3[5];\nz q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q2;\ncx q1[0], q2[0];\ncx q1[1], q2[1];\ncx q1[2], q2[2];\ncx q1[3], q2[3];\ncx q1[4], q2[4];\ncx q1[5], q2[5];\ncx q1[6], q2[6];\nbarrier q1, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT6[0];\nmeasure q2[1] -> cT6[1];\nmeasure q2[2] -> cT6[2];\nmeasure q2[3] -> cT6[3];\nmeasure q2[4] -> cT6[4];\nmeasure q2[5] -> cT6[5];\nmeasure q2[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q1[4];\nif(cT6_log[0] == 1) x q1[5];\nif(cT6_log[0] == 1) x q1[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT7_log_raw = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT7_log = cT7_log_raw;\nif(syn_measT7 == 2) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 4) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 6) cT7_log = cT7_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT7_log = cT7_log ^ pf[0];\n\n//Logical X\nif(cT7_log[0] == 1) x q2[4];\nif(cT7_log[0] == 1) x q2[5];\nif(cT7_log[0] == 1) x q2[6];\n\nif(cT7_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT8[0];\nmeasure q3[1] -> cT8[1];\nmeasure q3[2] -> cT8[2];\nmeasure q3[3] -> cT8[3];\nmeasure q3[4] -> cT8[4];\nmeasure q3[5] -> cT8[5];\nmeasure q3[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT8_log_raw = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT8_log = cT8_log_raw;\nif(syn_measT8 == 2) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 4) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 6) cT8_log = cT8_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT8_log = cT8_log ^ pf[0];\n\n//Logical X\nif(cT8_log[0] == 1) x q1[4];\nif(cT8_log[0] == 1) x q1[5];\nif(cT8_log[0] == 1) x q1[6];\n\nif(cT8_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT9_log_raw = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT9_log = cT9_log_raw;\nif(syn_measT9 == 2) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 4) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 6) cT9_log = cT9_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT9_log = cT9_log ^ pf[0];\n\n//Logical X\nif(cT9_log[0] == 1) x q3[4];\nif(cT9_log[0] == 1) x q3[5];\nif(cT9_log[0] == 1) x q3[6];\n\nif(cT9_log[0] == 1) rz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT10[0];\nmeasure q3[1] -> cT10[1];\nmeasure q3[2] -> cT10[2];\nmeasure q3[3] -> cT10[3];\nmeasure q3[4] -> cT10[4];\nmeasure q3[5] -> cT10[5];\nmeasure q3[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT10_log_raw = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT10_log = cT10_log_raw;\nif(syn_measT10 == 2) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 4) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 6) cT10_log = cT10_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT10_log = cT10_log ^ pf[0];\n\n//Logical X\nif(cT10_log[0] == 1) x q1[4];\nif(cT10_log[0] == 1) x q1[5];\nif(cT10_log[0] == 1) x q1[6];\n\nif(cT10_log[0] == 1) rz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q0;\ncx q3[0], q0[0];\ncx q3[1], q0[1];\ncx q3[2], q0[2];\ncx q3[3], q0[3];\ncx q3[4], q0[4];\ncx q3[5], q0[5];\ncx q3[6], q0[6];\nbarrier q3, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT11[0];\nmeasure q0[1] -> cT11[1];\nmeasure q0[2] -> cT11[2];\nmeasure q0[3] -> cT11[3];\nmeasure q0[4] -> cT11[4];\nmeasure q0[5] -> cT11[5];\nmeasure q0[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT11_log_raw = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT11_log = cT11_log_raw;\nif(syn_measT11 == 2) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 4) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 6) cT11_log = cT11_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT11_log = cT11_log ^ pf[0];\n\n//Logical X\nif(cT11_log[0] == 1) x q3[4];\nif(cT11_log[0] == 1) x q3[5];\nif(cT11_log[0] == 1) x q3[6];\n\nif(cT11_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\nbarrier q3;\nbarrier q1;\nbarrier q2;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c0[0];\nmeasure q3[1] -> c0[1];\nmeasure q3[2] -> c0[2];\nmeasure q3[3] -> c0[3];\nmeasure q3[4] -> c0[4];\nmeasure q3[5] -> c0[5];\nmeasure q3[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> c2[0];\nmeasure q2[1] -> c2[1];\nmeasure q2[2] -> c2[2];\nmeasure q2[3] -> c2[3];\nmeasure q2[4] -> c2[4];\nmeasure q2[5] -> c2[5];\nmeasure q2[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];\nc[2] = c2_log[0];"}, "6": {"parameters": ["comp", "100"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg init[4];\ncreg c0[7];\ncreg c1[7];\ncreg c2[7];\ncreg c0_log_raw[7];\ncreg c1_log_raw[7];\ncreg c2_log_raw[7];\ncreg c0_log[7];\ncreg c1_log[7];\ncreg c2_log[7];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\ncreg syn_meas2[3];\ncreg c[3];\ncreg c_mid[7];\ncreg c_mid_log_raw[1];\ncreg c_mid_log[1];\ncreg syn_meas_mid[3];\ncreg cT1[7];\ncreg cT2[7];\ncreg cT3[7];\ncreg cT4[7];\ncreg cT5[7];\ncreg cT6[7];\ncreg cT7[7];\ncreg cT8[7];\ncreg cT9[7];\ncreg cT10[7];\ncreg cT11[7];\ncreg cT12[7];\ncreg cT13[7];\ncreg cT1_log_raw[1];\ncreg cT2_log_raw[1];\ncreg cT3_log_raw[1];\ncreg cT4_log_raw[1];\ncreg cT5_log_raw[1];\ncreg cT6_log_raw[1];\ncreg cT7_log_raw[1];\ncreg cT8_log_raw[1];\ncreg cT9_log_raw[1];\ncreg cT10_log_raw[1];\ncreg cT11_log_raw[1];\ncreg cT12_log_raw[1];\ncreg cT13_log_raw[1];\ncreg cT1_log[1];\ncreg cT2_log[1];\ncreg cT3_log[1];\ncreg cT4_log[1];\ncreg cT5_log[1];\ncreg cT6_log[1];\ncreg cT7_log[1];\ncreg cT8_log[1];\ncreg cT9_log[1];\ncreg cT10_log[1];\ncreg cT11_log[1];\ncreg cT12_log[1];\ncreg cT13_log[1];\ncreg syn_measT1[3];\ncreg syn_measT2[3];\ncreg syn_measT3[3];\ncreg syn_measT4[3];\ncreg syn_measT5[3];\ncreg syn_measT6[3];\ncreg syn_measT7[3];\ncreg syn_measT8[3];\ncreg syn_measT9[3];\ncreg syn_measT10[3];\ncreg syn_measT11[3];\ncreg syn_measT12[3];\ncreg syn_measT13[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Logical H\nh q2;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT1_log = cT1_log_raw;\nif(syn_measT1 == 2) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 4) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 6) cT1_log = cT1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT1_log = cT1_log ^ pf[0];\n\n//Logical X\nif(cT1_log[0] == 1) x q3[4];\nif(cT1_log[0] == 1) x q3[5];\nif(cT1_log[0] == 1) x q3[6];\n\nif(cT1_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q1[4];\nif(cT2_log[0] == 1) x q1[5];\nif(cT2_log[0] == 1) x q1[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q1[4];\nif(cT4_log[0] == 1) x q1[5];\nif(cT4_log[0] == 1) x q1[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c_mid[0];\nmeasure q3[1] -> c_mid[1];\nmeasure q3[2] -> c_mid[2];\nmeasure q3[3] -> c_mid[3];\nmeasure q3[4] -> c_mid[4];\nmeasure q3[5] -> c_mid[5];\nmeasure q3[6] -> c_mid[6];\n\n// determine raw logical output\n// ============================\nc_mid_log_raw = c_mid[4] ^ c_mid[5] ^ c_mid[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas_mid[0] = c_mid[0] ^ c_mid[1] ^ c_mid[2] ^ c_mid[3];\nsyn_meas_mid[1] = c_mid[1] ^ c_mid[2] ^ c_mid[4] ^ c_mid[5];\nsyn_meas_mid[2] = c_mid[2] ^ c_mid[3] ^ c_mid[5] ^ c_mid[6];\n\n// XOR syndromes\nsyn_meas_mid = syn_meas_mid ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_mid_log = c_mid_log_raw;\nif(syn_meas_mid == 2) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 4) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 6) c_mid_log = c_mid_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_mid_log = c_mid_log ^ pf[0];\n// Logical H\nif(c_mid_log[0] == 1) h q2;\n\n// Transversal Logical CX\nif(c_mid_log[0] == 1) barrier q0, q2;\nif(c_mid_log[0] == 1) cx q0[0], q2[0];\nif(c_mid_log[0] == 1) cx q0[1], q2[1];\nif(c_mid_log[0] == 1) cx q0[2], q2[2];\nif(c_mid_log[0] == 1) cx q0[3], q2[3];\nif(c_mid_log[0] == 1) cx q0[4], q2[4];\nif(c_mid_log[0] == 1) cx q0[5], q2[5];\nif(c_mid_log[0] == 1) cx q0[6], q2[6];\nif(c_mid_log[0] == 1) barrier q0, q2;\n\n// Logical H\nif(c_mid_log[0] == 1) h q2;\nreset q3;\n\nbarrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nreset q3;\nreset q1[0];\nbarrier q3, q1[0];\n\nh q3[0];\nh q3[4];\nh q3[6];\n\ncx q3[4],q3[5];\ncx q3[0],q3[1];\ncx q3[6],q3[3];\ncx q3[4],q3[2];\ncx q3[6],q3[5];\ncx q3[0],q3[3];\ncx q3[4],q3[1];\ncx q3[3], q3[2];\n\nbarrier q1[0],q3[1],q3[3],q3[5];\n//verification step\ncx q3[5],q1[0];\ncx q3[1],q1[0];\ncx q3[3],q1[0];\nmeasure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q2;\ncx q1[0], q2[0];\ncx q1[1], q2[1];\ncx q1[2], q2[2];\ncx q1[3], q2[3];\ncx q1[4], q2[4];\ncx q1[5], q2[5];\ncx q1[6], q2[6];\nbarrier q1, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT6[0];\nmeasure q2[1] -> cT6[1];\nmeasure q2[2] -> cT6[2];\nmeasure q2[3] -> cT6[3];\nmeasure q2[4] -> cT6[4];\nmeasure q2[5] -> cT6[5];\nmeasure q2[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q1[4];\nif(cT6_log[0] == 1) x q1[5];\nif(cT6_log[0] == 1) x q1[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT7_log_raw = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT7_log = cT7_log_raw;\nif(syn_measT7 == 2) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 4) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 6) cT7_log = cT7_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT7_log = cT7_log ^ pf[0];\n\n//Logical X\nif(cT7_log[0] == 1) x q2[4];\nif(cT7_log[0] == 1) x q2[5];\nif(cT7_log[0] == 1) x q2[6];\n\nif(cT7_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT8[0];\nmeasure q3[1] -> cT8[1];\nmeasure q3[2] -> cT8[2];\nmeasure q3[3] -> cT8[3];\nmeasure q3[4] -> cT8[4];\nmeasure q3[5] -> cT8[5];\nmeasure q3[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT8_log_raw = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT8_log = cT8_log_raw;\nif(syn_measT8 == 2) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 4) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 6) cT8_log = cT8_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT8_log = cT8_log ^ pf[0];\n\n//Logical X\nif(cT8_log[0] == 1) x q1[4];\nif(cT8_log[0] == 1) x q1[5];\nif(cT8_log[0] == 1) x q1[6];\n\nif(cT8_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT9_log_raw = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT9_log = cT9_log_raw;\nif(syn_measT9 == 2) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 4) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 6) cT9_log = cT9_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT9_log = cT9_log ^ pf[0];\n\n//Logical X\nif(cT9_log[0] == 1) x q3[4];\nif(cT9_log[0] == 1) x q3[5];\nif(cT9_log[0] == 1) x q3[6];\n\nif(cT9_log[0] == 1) rz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT10[0];\nmeasure q3[1] -> cT10[1];\nmeasure q3[2] -> cT10[2];\nmeasure q3[3] -> cT10[3];\nmeasure q3[4] -> cT10[4];\nmeasure q3[5] -> cT10[5];\nmeasure q3[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT10_log_raw = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT10_log = cT10_log_raw;\nif(syn_measT10 == 2) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 4) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 6) cT10_log = cT10_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT10_log = cT10_log ^ pf[0];\n\n//Logical X\nif(cT10_log[0] == 1) x q1[4];\nif(cT10_log[0] == 1) x q1[5];\nif(cT10_log[0] == 1) x q1[6];\n\nif(cT10_log[0] == 1) rz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q0;\ncx q3[0], q0[0];\ncx q3[1], q0[1];\ncx q3[2], q0[2];\ncx q3[3], q0[3];\ncx q3[4], q0[4];\ncx q3[5], q0[5];\ncx q3[6], q0[6];\nbarrier q3, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT11[0];\nmeasure q0[1] -> cT11[1];\nmeasure q0[2] -> cT11[2];\nmeasure q0[3] -> cT11[3];\nmeasure q0[4] -> cT11[4];\nmeasure q0[5] -> cT11[5];\nmeasure q0[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT11_log_raw = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT11_log = cT11_log_raw;\nif(syn_measT11 == 2) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 4) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 6) cT11_log = cT11_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT11_log = cT11_log ^ pf[0];\n\n//Logical X\nif(cT11_log[0] == 1) x q3[4];\nif(cT11_log[0] == 1) x q3[5];\nif(cT11_log[0] == 1) x q3[6];\n\nif(cT11_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\nbarrier q3;\nbarrier q1;\nbarrier q2;\n// Logical H\nh q3;\n// Logical H\nh q1;\n// Logical H\nh q2;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c0[0];\nmeasure q3[1] -> c0[1];\nmeasure q3[2] -> c0[2];\nmeasure q3[3] -> c0[3];\nmeasure q3[4] -> c0[4];\nmeasure q3[5] -> c0[5];\nmeasure q3[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> c2[0];\nmeasure q2[1] -> c2[1];\nmeasure q2[2] -> c2[2];\nmeasure q2[3] -> c2[3];\nmeasure q2[4] -> c2[4];\nmeasure q2[5] -> c2[5];\nmeasure q2[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];\nc[2] = c2_log[0];"}, "7": {"parameters": ["comp", "011"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg init[4];\ncreg c0[7];\ncreg c1[7];\ncreg c2[7];\ncreg c0_log_raw[7];\ncreg c1_log_raw[7];\ncreg c2_log_raw[7];\ncreg c0_log[7];\ncreg c1_log[7];\ncreg c2_log[7];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\ncreg syn_meas2[3];\ncreg c[3];\ncreg c_mid[7];\ncreg c_mid_log_raw[1];\ncreg c_mid_log[1];\ncreg syn_meas_mid[3];\ncreg cT1[7];\ncreg cT2[7];\ncreg cT3[7];\ncreg cT4[7];\ncreg cT5[7];\ncreg cT6[7];\ncreg cT7[7];\ncreg cT8[7];\ncreg cT9[7];\ncreg cT10[7];\ncreg cT11[7];\ncreg cT12[7];\ncreg cT13[7];\ncreg cT1_log_raw[1];\ncreg cT2_log_raw[1];\ncreg cT3_log_raw[1];\ncreg cT4_log_raw[1];\ncreg cT5_log_raw[1];\ncreg cT6_log_raw[1];\ncreg cT7_log_raw[1];\ncreg cT8_log_raw[1];\ncreg cT9_log_raw[1];\ncreg cT10_log_raw[1];\ncreg cT11_log_raw[1];\ncreg cT12_log_raw[1];\ncreg cT13_log_raw[1];\ncreg cT1_log[1];\ncreg cT2_log[1];\ncreg cT3_log[1];\ncreg cT4_log[1];\ncreg cT5_log[1];\ncreg cT6_log[1];\ncreg cT7_log[1];\ncreg cT8_log[1];\ncreg cT9_log[1];\ncreg cT10_log[1];\ncreg cT11_log[1];\ncreg cT12_log[1];\ncreg cT13_log[1];\ncreg syn_measT1[3];\ncreg syn_measT2[3];\ncreg syn_measT3[3];\ncreg syn_measT4[3];\ncreg syn_measT5[3];\ncreg syn_measT6[3];\ncreg syn_measT7[3];\ncreg syn_measT8[3];\ncreg syn_measT9[3];\ncreg syn_measT10[3];\ncreg syn_measT11[3];\ncreg syn_measT12[3];\ncreg syn_measT13[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Logical H\nh q2;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT1_log = cT1_log_raw;\nif(syn_measT1 == 2) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 4) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 6) cT1_log = cT1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT1_log = cT1_log ^ pf[0];\n\n//Logical X\nif(cT1_log[0] == 1) x q3[4];\nif(cT1_log[0] == 1) x q3[5];\nif(cT1_log[0] == 1) x q3[6];\n\nif(cT1_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q1[4];\nif(cT2_log[0] == 1) x q1[5];\nif(cT2_log[0] == 1) x q1[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q1[4];\nif(cT4_log[0] == 1) x q1[5];\nif(cT4_log[0] == 1) x q1[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c_mid[0];\nmeasure q3[1] -> c_mid[1];\nmeasure q3[2] -> c_mid[2];\nmeasure q3[3] -> c_mid[3];\nmeasure q3[4] -> c_mid[4];\nmeasure q3[5] -> c_mid[5];\nmeasure q3[6] -> c_mid[6];\n\n// determine raw logical output\n// ============================\nc_mid_log_raw = c_mid[4] ^ c_mid[5] ^ c_mid[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas_mid[0] = c_mid[0] ^ c_mid[1] ^ c_mid[2] ^ c_mid[3];\nsyn_meas_mid[1] = c_mid[1] ^ c_mid[2] ^ c_mid[4] ^ c_mid[5];\nsyn_meas_mid[2] = c_mid[2] ^ c_mid[3] ^ c_mid[5] ^ c_mid[6];\n\n// XOR syndromes\nsyn_meas_mid = syn_meas_mid ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_mid_log = c_mid_log_raw;\nif(syn_meas_mid == 2) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 4) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 6) c_mid_log = c_mid_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_mid_log = c_mid_log ^ pf[0];\n// Logical H\nif(c_mid_log[0] == 1) h q2;\n\n// Transversal Logical CX\nif(c_mid_log[0] == 1) barrier q0, q2;\nif(c_mid_log[0] == 1) cx q0[0], q2[0];\nif(c_mid_log[0] == 1) cx q0[1], q2[1];\nif(c_mid_log[0] == 1) cx q0[2], q2[2];\nif(c_mid_log[0] == 1) cx q0[3], q2[3];\nif(c_mid_log[0] == 1) cx q0[4], q2[4];\nif(c_mid_log[0] == 1) cx q0[5], q2[5];\nif(c_mid_log[0] == 1) cx q0[6], q2[6];\nif(c_mid_log[0] == 1) barrier q0, q2;\n\n// Logical H\nif(c_mid_log[0] == 1) h q2;\nreset q3;\n\nbarrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nreset q3;\nreset q1[0];\nbarrier q3, q1[0];\n\nh q3[0];\nh q3[4];\nh q3[6];\n\ncx q3[4],q3[5];\ncx q3[0],q3[1];\ncx q3[6],q3[3];\ncx q3[4],q3[2];\ncx q3[6],q3[5];\ncx q3[0],q3[3];\ncx q3[4],q3[1];\ncx q3[3], q3[2];\n\nbarrier q1[0],q3[1],q3[3],q3[5];\n//verification step\ncx q3[5],q1[0];\ncx q3[1],q1[0];\ncx q3[3],q1[0];\nmeasure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q2;\ncx q1[0], q2[0];\ncx q1[1], q2[1];\ncx q1[2], q2[2];\ncx q1[3], q2[3];\ncx q1[4], q2[4];\ncx q1[5], q2[5];\ncx q1[6], q2[6];\nbarrier q1, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT6[0];\nmeasure q2[1] -> cT6[1];\nmeasure q2[2] -> cT6[2];\nmeasure q2[3] -> cT6[3];\nmeasure q2[4] -> cT6[4];\nmeasure q2[5] -> cT6[5];\nmeasure q2[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q1[4];\nif(cT6_log[0] == 1) x q1[5];\nif(cT6_log[0] == 1) x q1[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT7_log_raw = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT7_log = cT7_log_raw;\nif(syn_measT7 == 2) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 4) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 6) cT7_log = cT7_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT7_log = cT7_log ^ pf[0];\n\n//Logical X\nif(cT7_log[0] == 1) x q2[4];\nif(cT7_log[0] == 1) x q2[5];\nif(cT7_log[0] == 1) x q2[6];\n\nif(cT7_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT8[0];\nmeasure q3[1] -> cT8[1];\nmeasure q3[2] -> cT8[2];\nmeasure q3[3] -> cT8[3];\nmeasure q3[4] -> cT8[4];\nmeasure q3[5] -> cT8[5];\nmeasure q3[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT8_log_raw = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT8_log = cT8_log_raw;\nif(syn_measT8 == 2) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 4) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 6) cT8_log = cT8_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT8_log = cT8_log ^ pf[0];\n\n//Logical X\nif(cT8_log[0] == 1) x q1[4];\nif(cT8_log[0] == 1) x q1[5];\nif(cT8_log[0] == 1) x q1[6];\n\nif(cT8_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT9_log_raw = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT9_log = cT9_log_raw;\nif(syn_measT9 == 2) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 4) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 6) cT9_log = cT9_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT9_log = cT9_log ^ pf[0];\n\n//Logical X\nif(cT9_log[0] == 1) x q3[4];\nif(cT9_log[0] == 1) x q3[5];\nif(cT9_log[0] == 1) x q3[6];\n\nif(cT9_log[0] == 1) rz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT10[0];\nmeasure q3[1] -> cT10[1];\nmeasure q3[2] -> cT10[2];\nmeasure q3[3] -> cT10[3];\nmeasure q3[4] -> cT10[4];\nmeasure q3[5] -> cT10[5];\nmeasure q3[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT10_log_raw = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT10_log = cT10_log_raw;\nif(syn_measT10 == 2) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 4) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 6) cT10_log = cT10_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT10_log = cT10_log ^ pf[0];\n\n//Logical X\nif(cT10_log[0] == 1) x q1[4];\nif(cT10_log[0] == 1) x q1[5];\nif(cT10_log[0] == 1) x q1[6];\n\nif(cT10_log[0] == 1) rz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q0;\ncx q3[0], q0[0];\ncx q3[1], q0[1];\ncx q3[2], q0[2];\ncx q3[3], q0[3];\ncx q3[4], q0[4];\ncx q3[5], q0[5];\ncx q3[6], q0[6];\nbarrier q3, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT11[0];\nmeasure q0[1] -> cT11[1];\nmeasure q0[2] -> cT11[2];\nmeasure q0[3] -> cT11[3];\nmeasure q0[4] -> cT11[4];\nmeasure q0[5] -> cT11[5];\nmeasure q0[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT11_log_raw = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT11_log = cT11_log_raw;\nif(syn_measT11 == 2) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 4) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 6) cT11_log = cT11_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT11_log = cT11_log ^ pf[0];\n\n//Logical X\nif(cT11_log[0] == 1) x q3[4];\nif(cT11_log[0] == 1) x q3[5];\nif(cT11_log[0] == 1) x q3[6];\n\nif(cT11_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\nbarrier q3;\nbarrier q1;\nbarrier q2;\nrz(pi/2) q1;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q0[6];\nh q0[6];\nrz(pi/4) q0[6];\n\n// Encoding circuit\n// ---------------\nreset q0[0];\nreset q0[1];\nreset q0[2];\nreset q0[3];\nreset q0[4];\nreset q0[5];\n\n// q[6] is the input qubit\n\ncx q0[6],q0[5];\n\nh q0[1];\ncx q0[1], q0[0];\n\nh q0[2];\ncx q0[2], q0[4];\n\n// ---------------\nh q0[3];\ncx q0[3], q0[5];\ncx q0[2], q0[0];\ncx q0[6], q0[4];\n\n// ---------------\ncx q0[2], q0[6];\ncx q0[3], q0[4];\ncx q0[1], q0[5];\n\n// ---------------\ncx q0[1], q0[6];\ncx q0[3], q0[0];\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nrz(-pi/2) q0;\n\n// Transversal Logical CX\nbarrier q0, q2;\ncx q0[0], q2[0];\ncx q0[1], q2[1];\ncx q0[2], q2[2];\ncx q0[3], q2[3];\ncx q0[4], q2[4];\ncx q0[5], q2[5];\ncx q0[6], q2[6];\nbarrier q0, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT13[0];\nmeasure q2[1] -> cT13[1];\nmeasure q2[2] -> cT13[2];\nmeasure q2[3] -> cT13[3];\nmeasure q2[4] -> cT13[4];\nmeasure q2[5] -> cT13[5];\nmeasure q2[6] -> cT13[6];\n\n// determine raw logical output\n// ============================\ncT13_log_raw = cT13[4] ^ cT13[5] ^ cT13[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT13[0] = cT13[0] ^ cT13[1] ^ cT13[2] ^ cT13[3];\nsyn_measT13[1] = cT13[1] ^ cT13[2] ^ cT13[4] ^ cT13[5];\nsyn_measT13[2] = cT13[2] ^ cT13[3] ^ cT13[5] ^ cT13[6];\n\n// XOR syndromes\nsyn_measT13 = syn_measT13 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT13_log = cT13_log_raw;\nif(syn_measT13 == 2) cT13_log = cT13_log ^ 1;\nif(syn_measT13 == 4) cT13_log = cT13_log ^ 1;\nif(syn_measT13 == 6) cT13_log = cT13_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT13_log = cT13_log ^ pf[0];\n\n//Logical X\nif(cT13_log[0] == 1) x q0[4];\nif(cT13_log[0] == 1) x q0[5];\nif(cT13_log[0] == 1) x q0[6];\n\nif(cT13_log[0] == 1) rz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nrz(pi/2) q0;\n// Logical H\nh q3;\n// Logical H\nh q1;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c0[0];\nmeasure q3[1] -> c0[1];\nmeasure q3[2] -> c0[2];\nmeasure q3[3] -> c0[3];\nmeasure q3[4] -> c0[4];\nmeasure q3[5] -> c0[5];\nmeasure q3[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c2[0];\nmeasure q0[1] -> c2[1];\nmeasure q0[2] -> c2[2];\nmeasure q0[3] -> c2[3];\nmeasure q0[4] -> c2[4];\nmeasure q0[5] -> c2[5];\nmeasure q0[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];\nc[2] = c2_log[0];"}, "8": {"parameters": ["comp", "001"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg init[4];\ncreg c0[7];\ncreg c1[7];\ncreg c2[7];\ncreg c0_log_raw[7];\ncreg c1_log_raw[7];\ncreg c2_log_raw[7];\ncreg c0_log[7];\ncreg c1_log[7];\ncreg c2_log[7];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\ncreg syn_meas2[3];\ncreg c[3];\ncreg c_mid[7];\ncreg c_mid_log_raw[1];\ncreg c_mid_log[1];\ncreg syn_meas_mid[3];\ncreg cT1[7];\ncreg cT2[7];\ncreg cT3[7];\ncreg cT4[7];\ncreg cT5[7];\ncreg cT6[7];\ncreg cT7[7];\ncreg cT8[7];\ncreg cT9[7];\ncreg cT10[7];\ncreg cT11[7];\ncreg cT12[7];\ncreg cT13[7];\ncreg cT1_log_raw[1];\ncreg cT2_log_raw[1];\ncreg cT3_log_raw[1];\ncreg cT4_log_raw[1];\ncreg cT5_log_raw[1];\ncreg cT6_log_raw[1];\ncreg cT7_log_raw[1];\ncreg cT8_log_raw[1];\ncreg cT9_log_raw[1];\ncreg cT10_log_raw[1];\ncreg cT11_log_raw[1];\ncreg cT12_log_raw[1];\ncreg cT13_log_raw[1];\ncreg cT1_log[1];\ncreg cT2_log[1];\ncreg cT3_log[1];\ncreg cT4_log[1];\ncreg cT5_log[1];\ncreg cT6_log[1];\ncreg cT7_log[1];\ncreg cT8_log[1];\ncreg cT9_log[1];\ncreg cT10_log[1];\ncreg cT11_log[1];\ncreg cT12_log[1];\ncreg cT13_log[1];\ncreg syn_measT1[3];\ncreg syn_measT2[3];\ncreg syn_measT3[3];\ncreg syn_measT4[3];\ncreg syn_measT5[3];\ncreg syn_measT6[3];\ncreg syn_measT7[3];\ncreg syn_measT8[3];\ncreg syn_measT9[3];\ncreg syn_measT10[3];\ncreg syn_measT11[3];\ncreg syn_measT12[3];\ncreg syn_measT13[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Logical H\nh q2;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT1_log = cT1_log_raw;\nif(syn_measT1 == 2) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 4) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 6) cT1_log = cT1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT1_log = cT1_log ^ pf[0];\n\n//Logical X\nif(cT1_log[0] == 1) x q3[4];\nif(cT1_log[0] == 1) x q3[5];\nif(cT1_log[0] == 1) x q3[6];\n\nif(cT1_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q1[4];\nif(cT2_log[0] == 1) x q1[5];\nif(cT2_log[0] == 1) x q1[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q1[4];\nif(cT4_log[0] == 1) x q1[5];\nif(cT4_log[0] == 1) x q1[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c_mid[0];\nmeasure q3[1] -> c_mid[1];\nmeasure q3[2] -> c_mid[2];\nmeasure q3[3] -> c_mid[3];\nmeasure q3[4] -> c_mid[4];\nmeasure q3[5] -> c_mid[5];\nmeasure q3[6] -> c_mid[6];\n\n// determine raw logical output\n// ============================\nc_mid_log_raw = c_mid[4] ^ c_mid[5] ^ c_mid[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas_mid[0] = c_mid[0] ^ c_mid[1] ^ c_mid[2] ^ c_mid[3];\nsyn_meas_mid[1] = c_mid[1] ^ c_mid[2] ^ c_mid[4] ^ c_mid[5];\nsyn_meas_mid[2] = c_mid[2] ^ c_mid[3] ^ c_mid[5] ^ c_mid[6];\n\n// XOR syndromes\nsyn_meas_mid = syn_meas_mid ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_mid_log = c_mid_log_raw;\nif(syn_meas_mid == 2) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 4) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 6) c_mid_log = c_mid_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_mid_log = c_mid_log ^ pf[0];\n// Logical H\nif(c_mid_log[0] == 1) h q2;\n\n// Transversal Logical CX\nif(c_mid_log[0] == 1) barrier q0, q2;\nif(c_mid_log[0] == 1) cx q0[0], q2[0];\nif(c_mid_log[0] == 1) cx q0[1], q2[1];\nif(c_mid_log[0] == 1) cx q0[2], q2[2];\nif(c_mid_log[0] == 1) cx q0[3], q2[3];\nif(c_mid_log[0] == 1) cx q0[4], q2[4];\nif(c_mid_log[0] == 1) cx q0[5], q2[5];\nif(c_mid_log[0] == 1) cx q0[6], q2[6];\nif(c_mid_log[0] == 1) barrier q0, q2;\n\n// Logical H\nif(c_mid_log[0] == 1) h q2;\nreset q3;\n\nbarrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nreset q3;\nreset q1[0];\nbarrier q3, q1[0];\n\nh q3[0];\nh q3[4];\nh q3[6];\n\ncx q3[4],q3[5];\ncx q3[0],q3[1];\ncx q3[6],q3[3];\ncx q3[4],q3[2];\ncx q3[6],q3[5];\ncx q3[0],q3[3];\ncx q3[4],q3[1];\ncx q3[3], q3[2];\n\nbarrier q1[0],q3[1],q3[3],q3[5];\n//verification step\ncx q3[5],q1[0];\ncx q3[1],q1[0];\ncx q3[3],q1[0];\nmeasure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q2;\ncx q1[0], q2[0];\ncx q1[1], q2[1];\ncx q1[2], q2[2];\ncx q1[3], q2[3];\ncx q1[4], q2[4];\ncx q1[5], q2[5];\ncx q1[6], q2[6];\nbarrier q1, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT6[0];\nmeasure q2[1] -> cT6[1];\nmeasure q2[2] -> cT6[2];\nmeasure q2[3] -> cT6[3];\nmeasure q2[4] -> cT6[4];\nmeasure q2[5] -> cT6[5];\nmeasure q2[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q1[4];\nif(cT6_log[0] == 1) x q1[5];\nif(cT6_log[0] == 1) x q1[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT7_log_raw = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT7_log = cT7_log_raw;\nif(syn_measT7 == 2) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 4) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 6) cT7_log = cT7_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT7_log = cT7_log ^ pf[0];\n\n//Logical X\nif(cT7_log[0] == 1) x q2[4];\nif(cT7_log[0] == 1) x q2[5];\nif(cT7_log[0] == 1) x q2[6];\n\nif(cT7_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT8[0];\nmeasure q3[1] -> cT8[1];\nmeasure q3[2] -> cT8[2];\nmeasure q3[3] -> cT8[3];\nmeasure q3[4] -> cT8[4];\nmeasure q3[5] -> cT8[5];\nmeasure q3[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT8_log_raw = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT8_log = cT8_log_raw;\nif(syn_measT8 == 2) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 4) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 6) cT8_log = cT8_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT8_log = cT8_log ^ pf[0];\n\n//Logical X\nif(cT8_log[0] == 1) x q1[4];\nif(cT8_log[0] == 1) x q1[5];\nif(cT8_log[0] == 1) x q1[6];\n\nif(cT8_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT9_log_raw = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT9_log = cT9_log_raw;\nif(syn_measT9 == 2) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 4) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 6) cT9_log = cT9_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT9_log = cT9_log ^ pf[0];\n\n//Logical X\nif(cT9_log[0] == 1) x q3[4];\nif(cT9_log[0] == 1) x q3[5];\nif(cT9_log[0] == 1) x q3[6];\n\nif(cT9_log[0] == 1) rz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT10[0];\nmeasure q3[1] -> cT10[1];\nmeasure q3[2] -> cT10[2];\nmeasure q3[3] -> cT10[3];\nmeasure q3[4] -> cT10[4];\nmeasure q3[5] -> cT10[5];\nmeasure q3[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT10_log_raw = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT10_log = cT10_log_raw;\nif(syn_measT10 == 2) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 4) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 6) cT10_log = cT10_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT10_log = cT10_log ^ pf[0];\n\n//Logical X\nif(cT10_log[0] == 1) x q1[4];\nif(cT10_log[0] == 1) x q1[5];\nif(cT10_log[0] == 1) x q1[6];\n\nif(cT10_log[0] == 1) rz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q0;\ncx q3[0], q0[0];\ncx q3[1], q0[1];\ncx q3[2], q0[2];\ncx q3[3], q0[3];\ncx q3[4], q0[4];\ncx q3[5], q0[5];\ncx q3[6], q0[6];\nbarrier q3, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT11[0];\nmeasure q0[1] -> cT11[1];\nmeasure q0[2] -> cT11[2];\nmeasure q0[3] -> cT11[3];\nmeasure q0[4] -> cT11[4];\nmeasure q0[5] -> cT11[5];\nmeasure q0[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT11_log_raw = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT11_log = cT11_log_raw;\nif(syn_measT11 == 2) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 4) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 6) cT11_log = cT11_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT11_log = cT11_log ^ pf[0];\n\n//Logical X\nif(cT11_log[0] == 1) x q3[4];\nif(cT11_log[0] == 1) x q3[5];\nif(cT11_log[0] == 1) x q3[6];\n\nif(cT11_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\nbarrier q3;\nbarrier q1;\nbarrier q2;\nrz(pi/2) q1;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q0[6];\nh q0[6];\nrz(pi/4) q0[6];\n\n// Encoding circuit\n// ---------------\nreset q0[0];\nreset q0[1];\nreset q0[2];\nreset q0[3];\nreset q0[4];\nreset q0[5];\n\n// q[6] is the input qubit\n\ncx q0[6],q0[5];\n\nh q0[1];\ncx q0[1], q0[0];\n\nh q0[2];\ncx q0[2], q0[4];\n\n// ---------------\nh q0[3];\ncx q0[3], q0[5];\ncx q0[2], q0[0];\ncx q0[6], q0[4];\n\n// ---------------\ncx q0[2], q0[6];\ncx q0[3], q0[4];\ncx q0[1], q0[5];\n\n// ---------------\ncx q0[1], q0[6];\ncx q0[3], q0[0];\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nrz(-pi/2) q0;\n\n// Transversal Logical CX\nbarrier q0, q2;\ncx q0[0], q2[0];\ncx q0[1], q2[1];\ncx q0[2], q2[2];\ncx q0[3], q2[3];\ncx q0[4], q2[4];\ncx q0[5], q2[5];\ncx q0[6], q2[6];\nbarrier q0, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT13[0];\nmeasure q2[1] -> cT13[1];\nmeasure q2[2] -> cT13[2];\nmeasure q2[3] -> cT13[3];\nmeasure q2[4] -> cT13[4];\nmeasure q2[5] -> cT13[5];\nmeasure q2[6] -> cT13[6];\n\n// determine raw logical output\n// ============================\ncT13_log_raw = cT13[4] ^ cT13[5] ^ cT13[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT13[0] = cT13[0] ^ cT13[1] ^ cT13[2] ^ cT13[3];\nsyn_measT13[1] = cT13[1] ^ cT13[2] ^ cT13[4] ^ cT13[5];\nsyn_measT13[2] = cT13[2] ^ cT13[3] ^ cT13[5] ^ cT13[6];\n\n// XOR syndromes\nsyn_measT13 = syn_measT13 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT13_log = cT13_log_raw;\nif(syn_measT13 == 2) cT13_log = cT13_log ^ 1;\nif(syn_measT13 == 4) cT13_log = cT13_log ^ 1;\nif(syn_measT13 == 6) cT13_log = cT13_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT13_log = cT13_log ^ pf[0];\n\n//Logical X\nif(cT13_log[0] == 1) x q0[4];\nif(cT13_log[0] == 1) x q0[5];\nif(cT13_log[0] == 1) x q0[6];\n\nif(cT13_log[0] == 1) rz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Logical H\nh q3;\n// Logical H\nh q1;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c0[0];\nmeasure q3[1] -> c0[1];\nmeasure q3[2] -> c0[2];\nmeasure q3[3] -> c0[3];\nmeasure q3[4] -> c0[4];\nmeasure q3[5] -> c0[5];\nmeasure q3[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c2[0];\nmeasure q0[1] -> c2[1];\nmeasure q0[2] -> c2[2];\nmeasure q0[3] -> c2[3];\nmeasure q0[4] -> c2[4];\nmeasure q0[5] -> c2[5];\nmeasure q0[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];\nc[2] = c2_log[0];"}, "9": {"parameters": ["fourier", "110"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg init[4];\ncreg c0[7];\ncreg c1[7];\ncreg c2[7];\ncreg c0_log_raw[7];\ncreg c1_log_raw[7];\ncreg c2_log_raw[7];\ncreg c0_log[7];\ncreg c1_log[7];\ncreg c2_log[7];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\ncreg syn_meas2[3];\ncreg c[3];\ncreg c_mid[7];\ncreg c_mid_log_raw[1];\ncreg c_mid_log[1];\ncreg syn_meas_mid[3];\ncreg cT1[7];\ncreg cT2[7];\ncreg cT3[7];\ncreg cT4[7];\ncreg cT5[7];\ncreg cT6[7];\ncreg cT7[7];\ncreg cT8[7];\ncreg cT9[7];\ncreg cT10[7];\ncreg cT11[7];\ncreg cT12[7];\ncreg cT13[7];\ncreg cT1_log_raw[1];\ncreg cT2_log_raw[1];\ncreg cT3_log_raw[1];\ncreg cT4_log_raw[1];\ncreg cT5_log_raw[1];\ncreg cT6_log_raw[1];\ncreg cT7_log_raw[1];\ncreg cT8_log_raw[1];\ncreg cT9_log_raw[1];\ncreg cT10_log_raw[1];\ncreg cT11_log_raw[1];\ncreg cT12_log_raw[1];\ncreg cT13_log_raw[1];\ncreg cT1_log[1];\ncreg cT2_log[1];\ncreg cT3_log[1];\ncreg cT4_log[1];\ncreg cT5_log[1];\ncreg cT6_log[1];\ncreg cT7_log[1];\ncreg cT8_log[1];\ncreg cT9_log[1];\ncreg cT10_log[1];\ncreg cT11_log[1];\ncreg cT12_log[1];\ncreg cT13_log[1];\ncreg syn_measT1[3];\ncreg syn_measT2[3];\ncreg syn_measT3[3];\ncreg syn_measT4[3];\ncreg syn_measT5[3];\ncreg syn_measT6[3];\ncreg syn_measT7[3];\ncreg syn_measT8[3];\ncreg syn_measT9[3];\ncreg syn_measT10[3];\ncreg syn_measT11[3];\ncreg syn_measT12[3];\ncreg syn_measT13[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n// Logical H\nh q0;\n// Logical H\nh q2;\nrz(pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT12[0];\nmeasure q3[1] -> cT12[1];\nmeasure q3[2] -> cT12[2];\nmeasure q3[3] -> cT12[3];\nmeasure q3[4] -> cT12[4];\nmeasure q3[5] -> cT12[5];\nmeasure q3[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT12_log_raw = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT12_log = cT12_log_raw;\nif(syn_measT12 == 2) cT12_log = cT12_log ^ 1;\nif(syn_measT12 == 4) cT12_log = cT12_log ^ 1;\nif(syn_measT12 == 6) cT12_log = cT12_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT12_log = cT12_log ^ pf[0];\nif(cT12_log[0] == 1) rz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical Z\nz q2[4];\nz q2[5];\nz q2[6];\n\n// Logical H\nh q2;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT1_log = cT1_log_raw;\nif(syn_measT1 == 2) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 4) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 6) cT1_log = cT1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT1_log = cT1_log ^ pf[0];\n\n//Logical X\nif(cT1_log[0] == 1) x q3[4];\nif(cT1_log[0] == 1) x q3[5];\nif(cT1_log[0] == 1) x q3[6];\n\nif(cT1_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q1[4];\nif(cT2_log[0] == 1) x q1[5];\nif(cT2_log[0] == 1) x q1[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q1[4];\nif(cT4_log[0] == 1) x q1[5];\nif(cT4_log[0] == 1) x q1[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c_mid[0];\nmeasure q3[1] -> c_mid[1];\nmeasure q3[2] -> c_mid[2];\nmeasure q3[3] -> c_mid[3];\nmeasure q3[4] -> c_mid[4];\nmeasure q3[5] -> c_mid[5];\nmeasure q3[6] -> c_mid[6];\n\n// determine raw logical output\n// ============================\nc_mid_log_raw = c_mid[4] ^ c_mid[5] ^ c_mid[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas_mid[0] = c_mid[0] ^ c_mid[1] ^ c_mid[2] ^ c_mid[3];\nsyn_meas_mid[1] = c_mid[1] ^ c_mid[2] ^ c_mid[4] ^ c_mid[5];\nsyn_meas_mid[2] = c_mid[2] ^ c_mid[3] ^ c_mid[5] ^ c_mid[6];\n\n// XOR syndromes\nsyn_meas_mid = syn_meas_mid ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_mid_log = c_mid_log_raw;\nif(syn_meas_mid == 2) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 4) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 6) c_mid_log = c_mid_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_mid_log = c_mid_log ^ pf[0];\n// Logical H\nif(c_mid_log[0] == 1) h q2;\n\n// Transversal Logical CX\nif(c_mid_log[0] == 1) barrier q0, q2;\nif(c_mid_log[0] == 1) cx q0[0], q2[0];\nif(c_mid_log[0] == 1) cx q0[1], q2[1];\nif(c_mid_log[0] == 1) cx q0[2], q2[2];\nif(c_mid_log[0] == 1) cx q0[3], q2[3];\nif(c_mid_log[0] == 1) cx q0[4], q2[4];\nif(c_mid_log[0] == 1) cx q0[5], q2[5];\nif(c_mid_log[0] == 1) cx q0[6], q2[6];\nif(c_mid_log[0] == 1) barrier q0, q2;\n\n// Logical H\nif(c_mid_log[0] == 1) h q2;\nreset q3;\n\nbarrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nreset q3;\nreset q1[0];\nbarrier q3, q1[0];\n\nh q3[0];\nh q3[4];\nh q3[6];\n\ncx q3[4],q3[5];\ncx q3[0],q3[1];\ncx q3[6],q3[3];\ncx q3[4],q3[2];\ncx q3[6],q3[5];\ncx q3[0],q3[3];\ncx q3[4],q3[1];\ncx q3[3], q3[2];\n\nbarrier q1[0],q3[1],q3[3],q3[5];\n//verification step\ncx q3[5],q1[0];\ncx q3[1],q1[0];\ncx q3[3],q1[0];\nmeasure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\n// Logical H\nh q3;\n\n//Logical Z\nz q3[4];\nz q3[5];\nz q3[6];\n\nrz(pi/2) q3;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q2;\ncx q1[0], q2[0];\ncx q1[1], q2[1];\ncx q1[2], q2[2];\ncx q1[3], q2[3];\ncx q1[4], q2[4];\ncx q1[5], q2[5];\ncx q1[6], q2[6];\nbarrier q1, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT6[0];\nmeasure q2[1] -> cT6[1];\nmeasure q2[2] -> cT6[2];\nmeasure q2[3] -> cT6[3];\nmeasure q2[4] -> cT6[4];\nmeasure q2[5] -> cT6[5];\nmeasure q2[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q1[4];\nif(cT6_log[0] == 1) x q1[5];\nif(cT6_log[0] == 1) x q1[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT7_log_raw = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT7_log = cT7_log_raw;\nif(syn_measT7 == 2) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 4) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 6) cT7_log = cT7_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT7_log = cT7_log ^ pf[0];\n\n//Logical X\nif(cT7_log[0] == 1) x q2[4];\nif(cT7_log[0] == 1) x q2[5];\nif(cT7_log[0] == 1) x q2[6];\n\nif(cT7_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT8[0];\nmeasure q3[1] -> cT8[1];\nmeasure q3[2] -> cT8[2];\nmeasure q3[3] -> cT8[3];\nmeasure q3[4] -> cT8[4];\nmeasure q3[5] -> cT8[5];\nmeasure q3[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT8_log_raw = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT8_log = cT8_log_raw;\nif(syn_measT8 == 2) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 4) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 6) cT8_log = cT8_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT8_log = cT8_log ^ pf[0];\n\n//Logical X\nif(cT8_log[0] == 1) x q1[4];\nif(cT8_log[0] == 1) x q1[5];\nif(cT8_log[0] == 1) x q1[6];\n\nif(cT8_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT9_log_raw = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT9_log = cT9_log_raw;\nif(syn_measT9 == 2) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 4) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 6) cT9_log = cT9_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT9_log = cT9_log ^ pf[0];\n\n//Logical X\nif(cT9_log[0] == 1) x q3[4];\nif(cT9_log[0] == 1) x q3[5];\nif(cT9_log[0] == 1) x q3[6];\n\nif(cT9_log[0] == 1) rz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT10[0];\nmeasure q3[1] -> cT10[1];\nmeasure q3[2] -> cT10[2];\nmeasure q3[3] -> cT10[3];\nmeasure q3[4] -> cT10[4];\nmeasure q3[5] -> cT10[5];\nmeasure q3[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT10_log_raw = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT10_log = cT10_log_raw;\nif(syn_measT10 == 2) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 4) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 6) cT10_log = cT10_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT10_log = cT10_log ^ pf[0];\n\n//Logical X\nif(cT10_log[0] == 1) x q1[4];\nif(cT10_log[0] == 1) x q1[5];\nif(cT10_log[0] == 1) x q1[6];\n\nif(cT10_log[0] == 1) rz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q0;\ncx q3[0], q0[0];\ncx q3[1], q0[1];\ncx q3[2], q0[2];\ncx q3[3], q0[3];\ncx q3[4], q0[4];\ncx q3[5], q0[5];\ncx q3[6], q0[6];\nbarrier q3, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT11[0];\nmeasure q0[1] -> cT11[1];\nmeasure q0[2] -> cT11[2];\nmeasure q0[3] -> cT11[3];\nmeasure q0[4] -> cT11[4];\nmeasure q0[5] -> cT11[5];\nmeasure q0[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT11_log_raw = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT11_log = cT11_log_raw;\nif(syn_measT11 == 2) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 4) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 6) cT11_log = cT11_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT11_log = cT11_log ^ pf[0];\n\n//Logical X\nif(cT11_log[0] == 1) x q3[4];\nif(cT11_log[0] == 1) x q3[5];\nif(cT11_log[0] == 1) x q3[6];\n\nif(cT11_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\nbarrier q3;\nbarrier q1;\nbarrier q2;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c0[0];\nmeasure q3[1] -> c0[1];\nmeasure q3[2] -> c0[2];\nmeasure q3[3] -> c0[3];\nmeasure q3[4] -> c0[4];\nmeasure q3[5] -> c0[5];\nmeasure q3[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> c2[0];\nmeasure q2[1] -> c2[1];\nmeasure q2[2] -> c2[2];\nmeasure q2[3] -> c2[3];\nmeasure q2[4] -> c2[4];\nmeasure q2[5] -> c2[5];\nmeasure q2[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];\nc[2] = c2_log[0];"}, "10": {"parameters": ["fourier", "001"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg init[4];\ncreg c0[7];\ncreg c1[7];\ncreg c2[7];\ncreg c0_log_raw[7];\ncreg c1_log_raw[7];\ncreg c2_log_raw[7];\ncreg c0_log[7];\ncreg c1_log[7];\ncreg c2_log[7];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\ncreg syn_meas2[3];\ncreg c[3];\ncreg c_mid[7];\ncreg c_mid_log_raw[1];\ncreg c_mid_log[1];\ncreg syn_meas_mid[3];\ncreg cT1[7];\ncreg cT2[7];\ncreg cT3[7];\ncreg cT4[7];\ncreg cT5[7];\ncreg cT6[7];\ncreg cT7[7];\ncreg cT8[7];\ncreg cT9[7];\ncreg cT10[7];\ncreg cT11[7];\ncreg cT12[7];\ncreg cT13[7];\ncreg cT1_log_raw[1];\ncreg cT2_log_raw[1];\ncreg cT3_log_raw[1];\ncreg cT4_log_raw[1];\ncreg cT5_log_raw[1];\ncreg cT6_log_raw[1];\ncreg cT7_log_raw[1];\ncreg cT8_log_raw[1];\ncreg cT9_log_raw[1];\ncreg cT10_log_raw[1];\ncreg cT11_log_raw[1];\ncreg cT12_log_raw[1];\ncreg cT13_log_raw[1];\ncreg cT1_log[1];\ncreg cT2_log[1];\ncreg cT3_log[1];\ncreg cT4_log[1];\ncreg cT5_log[1];\ncreg cT6_log[1];\ncreg cT7_log[1];\ncreg cT8_log[1];\ncreg cT9_log[1];\ncreg cT10_log[1];\ncreg cT11_log[1];\ncreg cT12_log[1];\ncreg cT13_log[1];\ncreg syn_measT1[3];\ncreg syn_measT2[3];\ncreg syn_measT3[3];\ncreg syn_measT4[3];\ncreg syn_measT5[3];\ncreg syn_measT6[3];\ncreg syn_measT7[3];\ncreg syn_measT8[3];\ncreg syn_measT9[3];\ncreg syn_measT10[3];\ncreg syn_measT11[3];\ncreg syn_measT12[3];\ncreg syn_measT13[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n// Logical H\nh q0;\n// Logical H\nh q2;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\n// Logical H\nh q2;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT1_log = cT1_log_raw;\nif(syn_measT1 == 2) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 4) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 6) cT1_log = cT1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT1_log = cT1_log ^ pf[0];\n\n//Logical X\nif(cT1_log[0] == 1) x q3[4];\nif(cT1_log[0] == 1) x q3[5];\nif(cT1_log[0] == 1) x q3[6];\n\nif(cT1_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q1[4];\nif(cT2_log[0] == 1) x q1[5];\nif(cT2_log[0] == 1) x q1[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q1[4];\nif(cT4_log[0] == 1) x q1[5];\nif(cT4_log[0] == 1) x q1[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c_mid[0];\nmeasure q3[1] -> c_mid[1];\nmeasure q3[2] -> c_mid[2];\nmeasure q3[3] -> c_mid[3];\nmeasure q3[4] -> c_mid[4];\nmeasure q3[5] -> c_mid[5];\nmeasure q3[6] -> c_mid[6];\n\n// determine raw logical output\n// ============================\nc_mid_log_raw = c_mid[4] ^ c_mid[5] ^ c_mid[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas_mid[0] = c_mid[0] ^ c_mid[1] ^ c_mid[2] ^ c_mid[3];\nsyn_meas_mid[1] = c_mid[1] ^ c_mid[2] ^ c_mid[4] ^ c_mid[5];\nsyn_meas_mid[2] = c_mid[2] ^ c_mid[3] ^ c_mid[5] ^ c_mid[6];\n\n// XOR syndromes\nsyn_meas_mid = syn_meas_mid ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_mid_log = c_mid_log_raw;\nif(syn_meas_mid == 2) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 4) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 6) c_mid_log = c_mid_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_mid_log = c_mid_log ^ pf[0];\n// Logical H\nif(c_mid_log[0] == 1) h q2;\n\n// Transversal Logical CX\nif(c_mid_log[0] == 1) barrier q0, q2;\nif(c_mid_log[0] == 1) cx q0[0], q2[0];\nif(c_mid_log[0] == 1) cx q0[1], q2[1];\nif(c_mid_log[0] == 1) cx q0[2], q2[2];\nif(c_mid_log[0] == 1) cx q0[3], q2[3];\nif(c_mid_log[0] == 1) cx q0[4], q2[4];\nif(c_mid_log[0] == 1) cx q0[5], q2[5];\nif(c_mid_log[0] == 1) cx q0[6], q2[6];\nif(c_mid_log[0] == 1) barrier q0, q2;\n\n// Logical H\nif(c_mid_log[0] == 1) h q2;\nreset q3;\n\nbarrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nreset q3;\nreset q1[0];\nbarrier q3, q1[0];\n\nh q3[0];\nh q3[4];\nh q3[6];\n\ncx q3[4],q3[5];\ncx q3[0],q3[1];\ncx q3[6],q3[3];\ncx q3[4],q3[2];\ncx q3[6],q3[5];\ncx q3[0],q3[3];\ncx q3[4],q3[1];\ncx q3[3], q3[2];\n\nbarrier q1[0],q3[1],q3[3],q3[5];\n//verification step\ncx q3[5],q1[0];\ncx q3[1],q1[0];\ncx q3[3],q1[0];\nmeasure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\n// Logical H\nh q3;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q2;\ncx q1[0], q2[0];\ncx q1[1], q2[1];\ncx q1[2], q2[2];\ncx q1[3], q2[3];\ncx q1[4], q2[4];\ncx q1[5], q2[5];\ncx q1[6], q2[6];\nbarrier q1, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT6[0];\nmeasure q2[1] -> cT6[1];\nmeasure q2[2] -> cT6[2];\nmeasure q2[3] -> cT6[3];\nmeasure q2[4] -> cT6[4];\nmeasure q2[5] -> cT6[5];\nmeasure q2[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q1[4];\nif(cT6_log[0] == 1) x q1[5];\nif(cT6_log[0] == 1) x q1[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT7_log_raw = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT7_log = cT7_log_raw;\nif(syn_measT7 == 2) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 4) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 6) cT7_log = cT7_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT7_log = cT7_log ^ pf[0];\n\n//Logical X\nif(cT7_log[0] == 1) x q2[4];\nif(cT7_log[0] == 1) x q2[5];\nif(cT7_log[0] == 1) x q2[6];\n\nif(cT7_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT8[0];\nmeasure q3[1] -> cT8[1];\nmeasure q3[2] -> cT8[2];\nmeasure q3[3] -> cT8[3];\nmeasure q3[4] -> cT8[4];\nmeasure q3[5] -> cT8[5];\nmeasure q3[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT8_log_raw = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT8_log = cT8_log_raw;\nif(syn_measT8 == 2) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 4) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 6) cT8_log = cT8_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT8_log = cT8_log ^ pf[0];\n\n//Logical X\nif(cT8_log[0] == 1) x q1[4];\nif(cT8_log[0] == 1) x q1[5];\nif(cT8_log[0] == 1) x q1[6];\n\nif(cT8_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT9_log_raw = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT9_log = cT9_log_raw;\nif(syn_measT9 == 2) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 4) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 6) cT9_log = cT9_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT9_log = cT9_log ^ pf[0];\n\n//Logical X\nif(cT9_log[0] == 1) x q3[4];\nif(cT9_log[0] == 1) x q3[5];\nif(cT9_log[0] == 1) x q3[6];\n\nif(cT9_log[0] == 1) rz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT10[0];\nmeasure q3[1] -> cT10[1];\nmeasure q3[2] -> cT10[2];\nmeasure q3[3] -> cT10[3];\nmeasure q3[4] -> cT10[4];\nmeasure q3[5] -> cT10[5];\nmeasure q3[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT10_log_raw = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT10_log = cT10_log_raw;\nif(syn_measT10 == 2) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 4) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 6) cT10_log = cT10_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT10_log = cT10_log ^ pf[0];\n\n//Logical X\nif(cT10_log[0] == 1) x q1[4];\nif(cT10_log[0] == 1) x q1[5];\nif(cT10_log[0] == 1) x q1[6];\n\nif(cT10_log[0] == 1) rz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q0;\ncx q3[0], q0[0];\ncx q3[1], q0[1];\ncx q3[2], q0[2];\ncx q3[3], q0[3];\ncx q3[4], q0[4];\ncx q3[5], q0[5];\ncx q3[6], q0[6];\nbarrier q3, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT11[0];\nmeasure q0[1] -> cT11[1];\nmeasure q0[2] -> cT11[2];\nmeasure q0[3] -> cT11[3];\nmeasure q0[4] -> cT11[4];\nmeasure q0[5] -> cT11[5];\nmeasure q0[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT11_log_raw = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT11_log = cT11_log_raw;\nif(syn_measT11 == 2) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 4) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 6) cT11_log = cT11_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT11_log = cT11_log ^ pf[0];\n\n//Logical X\nif(cT11_log[0] == 1) x q3[4];\nif(cT11_log[0] == 1) x q3[5];\nif(cT11_log[0] == 1) x q3[6];\n\nif(cT11_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\nbarrier q3;\nbarrier q1;\nbarrier q2;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c0[0];\nmeasure q3[1] -> c0[1];\nmeasure q3[2] -> c0[2];\nmeasure q3[3] -> c0[3];\nmeasure q3[4] -> c0[4];\nmeasure q3[5] -> c0[5];\nmeasure q3[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> c2[0];\nmeasure q2[1] -> c2[1];\nmeasure q2[2] -> c2[2];\nmeasure q2[3] -> c2[3];\nmeasure q2[4] -> c2[4];\nmeasure q2[5] -> c2[5];\nmeasure q2[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];\nc[2] = c2_log[0];"}, "11": {"parameters": ["comp", "110"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg init[4];\ncreg c0[7];\ncreg c1[7];\ncreg c2[7];\ncreg c0_log_raw[7];\ncreg c1_log_raw[7];\ncreg c2_log_raw[7];\ncreg c0_log[7];\ncreg c1_log[7];\ncreg c2_log[7];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\ncreg syn_meas2[3];\ncreg c[3];\ncreg c_mid[7];\ncreg c_mid_log_raw[1];\ncreg c_mid_log[1];\ncreg syn_meas_mid[3];\ncreg cT1[7];\ncreg cT2[7];\ncreg cT3[7];\ncreg cT4[7];\ncreg cT5[7];\ncreg cT6[7];\ncreg cT7[7];\ncreg cT8[7];\ncreg cT9[7];\ncreg cT10[7];\ncreg cT11[7];\ncreg cT12[7];\ncreg cT13[7];\ncreg cT1_log_raw[1];\ncreg cT2_log_raw[1];\ncreg cT3_log_raw[1];\ncreg cT4_log_raw[1];\ncreg cT5_log_raw[1];\ncreg cT6_log_raw[1];\ncreg cT7_log_raw[1];\ncreg cT8_log_raw[1];\ncreg cT9_log_raw[1];\ncreg cT10_log_raw[1];\ncreg cT11_log_raw[1];\ncreg cT12_log_raw[1];\ncreg cT13_log_raw[1];\ncreg cT1_log[1];\ncreg cT2_log[1];\ncreg cT3_log[1];\ncreg cT4_log[1];\ncreg cT5_log[1];\ncreg cT6_log[1];\ncreg cT7_log[1];\ncreg cT8_log[1];\ncreg cT9_log[1];\ncreg cT10_log[1];\ncreg cT11_log[1];\ncreg cT12_log[1];\ncreg cT13_log[1];\ncreg syn_measT1[3];\ncreg syn_measT2[3];\ncreg syn_measT3[3];\ncreg syn_measT4[3];\ncreg syn_measT5[3];\ncreg syn_measT6[3];\ncreg syn_measT7[3];\ncreg syn_measT8[3];\ncreg syn_measT9[3];\ncreg syn_measT10[3];\ncreg syn_measT11[3];\ncreg syn_measT12[3];\ncreg syn_measT13[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Logical H\nh q2;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT1_log = cT1_log_raw;\nif(syn_measT1 == 2) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 4) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 6) cT1_log = cT1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT1_log = cT1_log ^ pf[0];\n\n//Logical X\nif(cT1_log[0] == 1) x q3[4];\nif(cT1_log[0] == 1) x q3[5];\nif(cT1_log[0] == 1) x q3[6];\n\nif(cT1_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q1[4];\nif(cT2_log[0] == 1) x q1[5];\nif(cT2_log[0] == 1) x q1[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q1[4];\nif(cT4_log[0] == 1) x q1[5];\nif(cT4_log[0] == 1) x q1[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c_mid[0];\nmeasure q3[1] -> c_mid[1];\nmeasure q3[2] -> c_mid[2];\nmeasure q3[3] -> c_mid[3];\nmeasure q3[4] -> c_mid[4];\nmeasure q3[5] -> c_mid[5];\nmeasure q3[6] -> c_mid[6];\n\n// determine raw logical output\n// ============================\nc_mid_log_raw = c_mid[4] ^ c_mid[5] ^ c_mid[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas_mid[0] = c_mid[0] ^ c_mid[1] ^ c_mid[2] ^ c_mid[3];\nsyn_meas_mid[1] = c_mid[1] ^ c_mid[2] ^ c_mid[4] ^ c_mid[5];\nsyn_meas_mid[2] = c_mid[2] ^ c_mid[3] ^ c_mid[5] ^ c_mid[6];\n\n// XOR syndromes\nsyn_meas_mid = syn_meas_mid ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_mid_log = c_mid_log_raw;\nif(syn_meas_mid == 2) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 4) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 6) c_mid_log = c_mid_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_mid_log = c_mid_log ^ pf[0];\n// Logical H\nif(c_mid_log[0] == 1) h q2;\n\n// Transversal Logical CX\nif(c_mid_log[0] == 1) barrier q0, q2;\nif(c_mid_log[0] == 1) cx q0[0], q2[0];\nif(c_mid_log[0] == 1) cx q0[1], q2[1];\nif(c_mid_log[0] == 1) cx q0[2], q2[2];\nif(c_mid_log[0] == 1) cx q0[3], q2[3];\nif(c_mid_log[0] == 1) cx q0[4], q2[4];\nif(c_mid_log[0] == 1) cx q0[5], q2[5];\nif(c_mid_log[0] == 1) cx q0[6], q2[6];\nif(c_mid_log[0] == 1) barrier q0, q2;\n\n// Logical H\nif(c_mid_log[0] == 1) h q2;\nreset q3;\n\nbarrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nreset q3;\nreset q1[0];\nbarrier q3, q1[0];\n\nh q3[0];\nh q3[4];\nh q3[6];\n\ncx q3[4],q3[5];\ncx q3[0],q3[1];\ncx q3[6],q3[3];\ncx q3[4],q3[2];\ncx q3[6],q3[5];\ncx q3[0],q3[3];\ncx q3[4],q3[1];\ncx q3[3], q3[2];\n\nbarrier q1[0],q3[1],q3[3],q3[5];\n//verification step\ncx q3[5],q1[0];\ncx q3[1],q1[0];\ncx q3[3],q1[0];\nmeasure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q2;\ncx q1[0], q2[0];\ncx q1[1], q2[1];\ncx q1[2], q2[2];\ncx q1[3], q2[3];\ncx q1[4], q2[4];\ncx q1[5], q2[5];\ncx q1[6], q2[6];\nbarrier q1, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT6[0];\nmeasure q2[1] -> cT6[1];\nmeasure q2[2] -> cT6[2];\nmeasure q2[3] -> cT6[3];\nmeasure q2[4] -> cT6[4];\nmeasure q2[5] -> cT6[5];\nmeasure q2[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q1[4];\nif(cT6_log[0] == 1) x q1[5];\nif(cT6_log[0] == 1) x q1[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT7_log_raw = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT7_log = cT7_log_raw;\nif(syn_measT7 == 2) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 4) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 6) cT7_log = cT7_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT7_log = cT7_log ^ pf[0];\n\n//Logical X\nif(cT7_log[0] == 1) x q2[4];\nif(cT7_log[0] == 1) x q2[5];\nif(cT7_log[0] == 1) x q2[6];\n\nif(cT7_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT8[0];\nmeasure q3[1] -> cT8[1];\nmeasure q3[2] -> cT8[2];\nmeasure q3[3] -> cT8[3];\nmeasure q3[4] -> cT8[4];\nmeasure q3[5] -> cT8[5];\nmeasure q3[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT8_log_raw = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT8_log = cT8_log_raw;\nif(syn_measT8 == 2) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 4) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 6) cT8_log = cT8_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT8_log = cT8_log ^ pf[0];\n\n//Logical X\nif(cT8_log[0] == 1) x q1[4];\nif(cT8_log[0] == 1) x q1[5];\nif(cT8_log[0] == 1) x q1[6];\n\nif(cT8_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT9_log_raw = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT9_log = cT9_log_raw;\nif(syn_measT9 == 2) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 4) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 6) cT9_log = cT9_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT9_log = cT9_log ^ pf[0];\n\n//Logical X\nif(cT9_log[0] == 1) x q3[4];\nif(cT9_log[0] == 1) x q3[5];\nif(cT9_log[0] == 1) x q3[6];\n\nif(cT9_log[0] == 1) rz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT10[0];\nmeasure q3[1] -> cT10[1];\nmeasure q3[2] -> cT10[2];\nmeasure q3[3] -> cT10[3];\nmeasure q3[4] -> cT10[4];\nmeasure q3[5] -> cT10[5];\nmeasure q3[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT10_log_raw = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT10_log = cT10_log_raw;\nif(syn_measT10 == 2) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 4) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 6) cT10_log = cT10_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT10_log = cT10_log ^ pf[0];\n\n//Logical X\nif(cT10_log[0] == 1) x q1[4];\nif(cT10_log[0] == 1) x q1[5];\nif(cT10_log[0] == 1) x q1[6];\n\nif(cT10_log[0] == 1) rz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q0;\ncx q3[0], q0[0];\ncx q3[1], q0[1];\ncx q3[2], q0[2];\ncx q3[3], q0[3];\ncx q3[4], q0[4];\ncx q3[5], q0[5];\ncx q3[6], q0[6];\nbarrier q3, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT11[0];\nmeasure q0[1] -> cT11[1];\nmeasure q0[2] -> cT11[2];\nmeasure q0[3] -> cT11[3];\nmeasure q0[4] -> cT11[4];\nmeasure q0[5] -> cT11[5];\nmeasure q0[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT11_log_raw = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT11_log = cT11_log_raw;\nif(syn_measT11 == 2) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 4) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 6) cT11_log = cT11_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT11_log = cT11_log ^ pf[0];\n\n//Logical X\nif(cT11_log[0] == 1) x q3[4];\nif(cT11_log[0] == 1) x q3[5];\nif(cT11_log[0] == 1) x q3[6];\n\nif(cT11_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\nbarrier q3;\nbarrier q1;\nbarrier q2;\nrz(pi/2) q2;\n// Logical H\nh q3;\n// Logical H\nh q1;\n// Logical H\nh q2;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c0[0];\nmeasure q3[1] -> c0[1];\nmeasure q3[2] -> c0[2];\nmeasure q3[3] -> c0[3];\nmeasure q3[4] -> c0[4];\nmeasure q3[5] -> c0[5];\nmeasure q3[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> c2[0];\nmeasure q2[1] -> c2[1];\nmeasure q2[2] -> c2[2];\nmeasure q2[3] -> c2[3];\nmeasure q2[4] -> c2[4];\nmeasure q2[5] -> c2[5];\nmeasure q2[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];\nc[2] = c2_log[0];"}, "12": {"parameters": ["comp", "111"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg init[4];\ncreg c0[7];\ncreg c1[7];\ncreg c2[7];\ncreg c0_log_raw[7];\ncreg c1_log_raw[7];\ncreg c2_log_raw[7];\ncreg c0_log[7];\ncreg c1_log[7];\ncreg c2_log[7];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\ncreg syn_meas2[3];\ncreg c[3];\ncreg c_mid[7];\ncreg c_mid_log_raw[1];\ncreg c_mid_log[1];\ncreg syn_meas_mid[3];\ncreg cT1[7];\ncreg cT2[7];\ncreg cT3[7];\ncreg cT4[7];\ncreg cT5[7];\ncreg cT6[7];\ncreg cT7[7];\ncreg cT8[7];\ncreg cT9[7];\ncreg cT10[7];\ncreg cT11[7];\ncreg cT12[7];\ncreg cT13[7];\ncreg cT1_log_raw[1];\ncreg cT2_log_raw[1];\ncreg cT3_log_raw[1];\ncreg cT4_log_raw[1];\ncreg cT5_log_raw[1];\ncreg cT6_log_raw[1];\ncreg cT7_log_raw[1];\ncreg cT8_log_raw[1];\ncreg cT9_log_raw[1];\ncreg cT10_log_raw[1];\ncreg cT11_log_raw[1];\ncreg cT12_log_raw[1];\ncreg cT13_log_raw[1];\ncreg cT1_log[1];\ncreg cT2_log[1];\ncreg cT3_log[1];\ncreg cT4_log[1];\ncreg cT5_log[1];\ncreg cT6_log[1];\ncreg cT7_log[1];\ncreg cT8_log[1];\ncreg cT9_log[1];\ncreg cT10_log[1];\ncreg cT11_log[1];\ncreg cT12_log[1];\ncreg cT13_log[1];\ncreg syn_measT1[3];\ncreg syn_measT2[3];\ncreg syn_measT3[3];\ncreg syn_measT4[3];\ncreg syn_measT5[3];\ncreg syn_measT6[3];\ncreg syn_measT7[3];\ncreg syn_measT8[3];\ncreg syn_measT9[3];\ncreg syn_measT10[3];\ncreg syn_measT11[3];\ncreg syn_measT12[3];\ncreg syn_measT13[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Logical H\nh q2;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT1_log = cT1_log_raw;\nif(syn_measT1 == 2) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 4) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 6) cT1_log = cT1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT1_log = cT1_log ^ pf[0];\n\n//Logical X\nif(cT1_log[0] == 1) x q3[4];\nif(cT1_log[0] == 1) x q3[5];\nif(cT1_log[0] == 1) x q3[6];\n\nif(cT1_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q1[4];\nif(cT2_log[0] == 1) x q1[5];\nif(cT2_log[0] == 1) x q1[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q1[4];\nif(cT4_log[0] == 1) x q1[5];\nif(cT4_log[0] == 1) x q1[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c_mid[0];\nmeasure q3[1] -> c_mid[1];\nmeasure q3[2] -> c_mid[2];\nmeasure q3[3] -> c_mid[3];\nmeasure q3[4] -> c_mid[4];\nmeasure q3[5] -> c_mid[5];\nmeasure q3[6] -> c_mid[6];\n\n// determine raw logical output\n// ============================\nc_mid_log_raw = c_mid[4] ^ c_mid[5] ^ c_mid[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas_mid[0] = c_mid[0] ^ c_mid[1] ^ c_mid[2] ^ c_mid[3];\nsyn_meas_mid[1] = c_mid[1] ^ c_mid[2] ^ c_mid[4] ^ c_mid[5];\nsyn_meas_mid[2] = c_mid[2] ^ c_mid[3] ^ c_mid[5] ^ c_mid[6];\n\n// XOR syndromes\nsyn_meas_mid = syn_meas_mid ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_mid_log = c_mid_log_raw;\nif(syn_meas_mid == 2) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 4) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 6) c_mid_log = c_mid_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_mid_log = c_mid_log ^ pf[0];\n// Logical H\nif(c_mid_log[0] == 1) h q2;\n\n// Transversal Logical CX\nif(c_mid_log[0] == 1) barrier q0, q2;\nif(c_mid_log[0] == 1) cx q0[0], q2[0];\nif(c_mid_log[0] == 1) cx q0[1], q2[1];\nif(c_mid_log[0] == 1) cx q0[2], q2[2];\nif(c_mid_log[0] == 1) cx q0[3], q2[3];\nif(c_mid_log[0] == 1) cx q0[4], q2[4];\nif(c_mid_log[0] == 1) cx q0[5], q2[5];\nif(c_mid_log[0] == 1) cx q0[6], q2[6];\nif(c_mid_log[0] == 1) barrier q0, q2;\n\n// Logical H\nif(c_mid_log[0] == 1) h q2;\nreset q3;\n\nbarrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nreset q3;\nreset q1[0];\nbarrier q3, q1[0];\n\nh q3[0];\nh q3[4];\nh q3[6];\n\ncx q3[4],q3[5];\ncx q3[0],q3[1];\ncx q3[6],q3[3];\ncx q3[4],q3[2];\ncx q3[6],q3[5];\ncx q3[0],q3[3];\ncx q3[4],q3[1];\ncx q3[3], q3[2];\n\nbarrier q1[0],q3[1],q3[3],q3[5];\n//verification step\ncx q3[5],q1[0];\ncx q3[1],q1[0];\ncx q3[3],q1[0];\nmeasure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q2;\ncx q1[0], q2[0];\ncx q1[1], q2[1];\ncx q1[2], q2[2];\ncx q1[3], q2[3];\ncx q1[4], q2[4];\ncx q1[5], q2[5];\ncx q1[6], q2[6];\nbarrier q1, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT6[0];\nmeasure q2[1] -> cT6[1];\nmeasure q2[2] -> cT6[2];\nmeasure q2[3] -> cT6[3];\nmeasure q2[4] -> cT6[4];\nmeasure q2[5] -> cT6[5];\nmeasure q2[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q1[4];\nif(cT6_log[0] == 1) x q1[5];\nif(cT6_log[0] == 1) x q1[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT7_log_raw = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT7_log = cT7_log_raw;\nif(syn_measT7 == 2) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 4) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 6) cT7_log = cT7_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT7_log = cT7_log ^ pf[0];\n\n//Logical X\nif(cT7_log[0] == 1) x q2[4];\nif(cT7_log[0] == 1) x q2[5];\nif(cT7_log[0] == 1) x q2[6];\n\nif(cT7_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT8[0];\nmeasure q3[1] -> cT8[1];\nmeasure q3[2] -> cT8[2];\nmeasure q3[3] -> cT8[3];\nmeasure q3[4] -> cT8[4];\nmeasure q3[5] -> cT8[5];\nmeasure q3[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT8_log_raw = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT8_log = cT8_log_raw;\nif(syn_measT8 == 2) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 4) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 6) cT8_log = cT8_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT8_log = cT8_log ^ pf[0];\n\n//Logical X\nif(cT8_log[0] == 1) x q1[4];\nif(cT8_log[0] == 1) x q1[5];\nif(cT8_log[0] == 1) x q1[6];\n\nif(cT8_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT9_log_raw = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT9_log = cT9_log_raw;\nif(syn_measT9 == 2) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 4) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 6) cT9_log = cT9_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT9_log = cT9_log ^ pf[0];\n\n//Logical X\nif(cT9_log[0] == 1) x q3[4];\nif(cT9_log[0] == 1) x q3[5];\nif(cT9_log[0] == 1) x q3[6];\n\nif(cT9_log[0] == 1) rz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT10[0];\nmeasure q3[1] -> cT10[1];\nmeasure q3[2] -> cT10[2];\nmeasure q3[3] -> cT10[3];\nmeasure q3[4] -> cT10[4];\nmeasure q3[5] -> cT10[5];\nmeasure q3[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT10_log_raw = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT10_log = cT10_log_raw;\nif(syn_measT10 == 2) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 4) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 6) cT10_log = cT10_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT10_log = cT10_log ^ pf[0];\n\n//Logical X\nif(cT10_log[0] == 1) x q1[4];\nif(cT10_log[0] == 1) x q1[5];\nif(cT10_log[0] == 1) x q1[6];\n\nif(cT10_log[0] == 1) rz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q0;\ncx q3[0], q0[0];\ncx q3[1], q0[1];\ncx q3[2], q0[2];\ncx q3[3], q0[3];\ncx q3[4], q0[4];\ncx q3[5], q0[5];\ncx q3[6], q0[6];\nbarrier q3, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT11[0];\nmeasure q0[1] -> cT11[1];\nmeasure q0[2] -> cT11[2];\nmeasure q0[3] -> cT11[3];\nmeasure q0[4] -> cT11[4];\nmeasure q0[5] -> cT11[5];\nmeasure q0[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT11_log_raw = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT11_log = cT11_log_raw;\nif(syn_measT11 == 2) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 4) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 6) cT11_log = cT11_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT11_log = cT11_log ^ pf[0];\n\n//Logical X\nif(cT11_log[0] == 1) x q3[4];\nif(cT11_log[0] == 1) x q3[5];\nif(cT11_log[0] == 1) x q3[6];\n\nif(cT11_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\nbarrier q3;\nbarrier q1;\nbarrier q2;\nrz(pi/2) q1;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q0[6];\nh q0[6];\nrz(pi/4) q0[6];\n\n// Encoding circuit\n// ---------------\nreset q0[0];\nreset q0[1];\nreset q0[2];\nreset q0[3];\nreset q0[4];\nreset q0[5];\n\n// q[6] is the input qubit\n\ncx q0[6],q0[5];\n\nh q0[1];\ncx q0[1], q0[0];\n\nh q0[2];\ncx q0[2], q0[4];\n\n// ---------------\nh q0[3];\ncx q0[3], q0[5];\ncx q0[2], q0[0];\ncx q0[6], q0[4];\n\n// ---------------\ncx q0[2], q0[6];\ncx q0[3], q0[4];\ncx q0[1], q0[5];\n\n// ---------------\ncx q0[1], q0[6];\ncx q0[3], q0[0];\n\n\n// Transversal Logical CX\nbarrier q0, q2;\ncx q0[0], q2[0];\ncx q0[1], q2[1];\ncx q0[2], q2[2];\ncx q0[3], q2[3];\ncx q0[4], q2[4];\ncx q0[5], q2[5];\ncx q0[6], q2[6];\nbarrier q0, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT13[0];\nmeasure q2[1] -> cT13[1];\nmeasure q2[2] -> cT13[2];\nmeasure q2[3] -> cT13[3];\nmeasure q2[4] -> cT13[4];\nmeasure q2[5] -> cT13[5];\nmeasure q2[6] -> cT13[6];\n\n// determine raw logical output\n// ============================\ncT13_log_raw = cT13[4] ^ cT13[5] ^ cT13[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT13[0] = cT13[0] ^ cT13[1] ^ cT13[2] ^ cT13[3];\nsyn_measT13[1] = cT13[1] ^ cT13[2] ^ cT13[4] ^ cT13[5];\nsyn_measT13[2] = cT13[2] ^ cT13[3] ^ cT13[5] ^ cT13[6];\n\n// XOR syndromes\nsyn_measT13 = syn_measT13 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT13_log = cT13_log_raw;\nif(syn_measT13 == 2) cT13_log = cT13_log ^ 1;\nif(syn_measT13 == 4) cT13_log = cT13_log ^ 1;\nif(syn_measT13 == 6) cT13_log = cT13_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT13_log = cT13_log ^ pf[0];\n\n//Logical X\nif(cT13_log[0] == 1) x q0[4];\nif(cT13_log[0] == 1) x q0[5];\nif(cT13_log[0] == 1) x q0[6];\n\nif(cT13_log[0] == 1) rz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\nrz(pi/2) q0;\n// Logical H\nh q3;\n// Logical H\nh q1;\n// Logical H\nh q0;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c0[0];\nmeasure q3[1] -> c0[1];\nmeasure q3[2] -> c0[2];\nmeasure q3[3] -> c0[3];\nmeasure q3[4] -> c0[4];\nmeasure q3[5] -> c0[5];\nmeasure q3[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> c2[0];\nmeasure q0[1] -> c2[1];\nmeasure q0[2] -> c2[2];\nmeasure q0[3] -> c2[3];\nmeasure q0[4] -> c2[4];\nmeasure q0[5] -> c2[5];\nmeasure q0[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];\nc[2] = c2_log[0];"}, "13": {"parameters": ["fourier", "101"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg init[4];\ncreg c0[7];\ncreg c1[7];\ncreg c2[7];\ncreg c0_log_raw[7];\ncreg c1_log_raw[7];\ncreg c2_log_raw[7];\ncreg c0_log[7];\ncreg c1_log[7];\ncreg c2_log[7];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\ncreg syn_meas2[3];\ncreg c[3];\ncreg c_mid[7];\ncreg c_mid_log_raw[1];\ncreg c_mid_log[1];\ncreg syn_meas_mid[3];\ncreg cT1[7];\ncreg cT2[7];\ncreg cT3[7];\ncreg cT4[7];\ncreg cT5[7];\ncreg cT6[7];\ncreg cT7[7];\ncreg cT8[7];\ncreg cT9[7];\ncreg cT10[7];\ncreg cT11[7];\ncreg cT12[7];\ncreg cT13[7];\ncreg cT1_log_raw[1];\ncreg cT2_log_raw[1];\ncreg cT3_log_raw[1];\ncreg cT4_log_raw[1];\ncreg cT5_log_raw[1];\ncreg cT6_log_raw[1];\ncreg cT7_log_raw[1];\ncreg cT8_log_raw[1];\ncreg cT9_log_raw[1];\ncreg cT10_log_raw[1];\ncreg cT11_log_raw[1];\ncreg cT12_log_raw[1];\ncreg cT13_log_raw[1];\ncreg cT1_log[1];\ncreg cT2_log[1];\ncreg cT3_log[1];\ncreg cT4_log[1];\ncreg cT5_log[1];\ncreg cT6_log[1];\ncreg cT7_log[1];\ncreg cT8_log[1];\ncreg cT9_log[1];\ncreg cT10_log[1];\ncreg cT11_log[1];\ncreg cT12_log[1];\ncreg cT13_log[1];\ncreg syn_measT1[3];\ncreg syn_measT2[3];\ncreg syn_measT3[3];\ncreg syn_measT4[3];\ncreg syn_measT5[3];\ncreg syn_measT6[3];\ncreg syn_measT7[3];\ncreg syn_measT8[3];\ncreg syn_measT9[3];\ncreg syn_measT10[3];\ncreg syn_measT11[3];\ncreg syn_measT12[3];\ncreg syn_measT13[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n// Logical H\nh q0;\n// Logical H\nh q2;\n\n//Logical Z\nz q0[4];\nz q0[5];\nz q0[6];\n\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT12[0];\nmeasure q3[1] -> cT12[1];\nmeasure q3[2] -> cT12[2];\nmeasure q3[3] -> cT12[3];\nmeasure q3[4] -> cT12[4];\nmeasure q3[5] -> cT12[5];\nmeasure q3[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT12_log_raw = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT12_log = cT12_log_raw;\nif(syn_measT12 == 2) cT12_log = cT12_log ^ 1;\nif(syn_measT12 == 4) cT12_log = cT12_log ^ 1;\nif(syn_measT12 == 6) cT12_log = cT12_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT12_log = cT12_log ^ pf[0];\nif(cT12_log[0] == 1) rz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical Z\nz q2[4];\nz q2[5];\nz q2[6];\n\n// Logical H\nh q2;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT1_log = cT1_log_raw;\nif(syn_measT1 == 2) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 4) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 6) cT1_log = cT1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT1_log = cT1_log ^ pf[0];\n\n//Logical X\nif(cT1_log[0] == 1) x q3[4];\nif(cT1_log[0] == 1) x q3[5];\nif(cT1_log[0] == 1) x q3[6];\n\nif(cT1_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q1[4];\nif(cT2_log[0] == 1) x q1[5];\nif(cT2_log[0] == 1) x q1[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q1[4];\nif(cT4_log[0] == 1) x q1[5];\nif(cT4_log[0] == 1) x q1[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c_mid[0];\nmeasure q3[1] -> c_mid[1];\nmeasure q3[2] -> c_mid[2];\nmeasure q3[3] -> c_mid[3];\nmeasure q3[4] -> c_mid[4];\nmeasure q3[5] -> c_mid[5];\nmeasure q3[6] -> c_mid[6];\n\n// determine raw logical output\n// ============================\nc_mid_log_raw = c_mid[4] ^ c_mid[5] ^ c_mid[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas_mid[0] = c_mid[0] ^ c_mid[1] ^ c_mid[2] ^ c_mid[3];\nsyn_meas_mid[1] = c_mid[1] ^ c_mid[2] ^ c_mid[4] ^ c_mid[5];\nsyn_meas_mid[2] = c_mid[2] ^ c_mid[3] ^ c_mid[5] ^ c_mid[6];\n\n// XOR syndromes\nsyn_meas_mid = syn_meas_mid ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_mid_log = c_mid_log_raw;\nif(syn_meas_mid == 2) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 4) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 6) c_mid_log = c_mid_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_mid_log = c_mid_log ^ pf[0];\n// Logical H\nif(c_mid_log[0] == 1) h q2;\n\n// Transversal Logical CX\nif(c_mid_log[0] == 1) barrier q0, q2;\nif(c_mid_log[0] == 1) cx q0[0], q2[0];\nif(c_mid_log[0] == 1) cx q0[1], q2[1];\nif(c_mid_log[0] == 1) cx q0[2], q2[2];\nif(c_mid_log[0] == 1) cx q0[3], q2[3];\nif(c_mid_log[0] == 1) cx q0[4], q2[4];\nif(c_mid_log[0] == 1) cx q0[5], q2[5];\nif(c_mid_log[0] == 1) cx q0[6], q2[6];\nif(c_mid_log[0] == 1) barrier q0, q2;\n\n// Logical H\nif(c_mid_log[0] == 1) h q2;\nreset q3;\n\nbarrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nreset q3;\nreset q1[0];\nbarrier q3, q1[0];\n\nh q3[0];\nh q3[4];\nh q3[6];\n\ncx q3[4],q3[5];\ncx q3[0],q3[1];\ncx q3[6],q3[3];\ncx q3[4],q3[2];\ncx q3[6],q3[5];\ncx q3[0],q3[3];\ncx q3[4],q3[1];\ncx q3[3], q3[2];\n\nbarrier q1[0],q3[1],q3[3],q3[5];\n//verification step\ncx q3[5],q1[0];\ncx q3[1],q1[0];\ncx q3[3],q1[0];\nmeasure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\n// Logical H\nh q3;\nrz(pi/2) q3;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q2;\ncx q1[0], q2[0];\ncx q1[1], q2[1];\ncx q1[2], q2[2];\ncx q1[3], q2[3];\ncx q1[4], q2[4];\ncx q1[5], q2[5];\ncx q1[6], q2[6];\nbarrier q1, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT6[0];\nmeasure q2[1] -> cT6[1];\nmeasure q2[2] -> cT6[2];\nmeasure q2[3] -> cT6[3];\nmeasure q2[4] -> cT6[4];\nmeasure q2[5] -> cT6[5];\nmeasure q2[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q1[4];\nif(cT6_log[0] == 1) x q1[5];\nif(cT6_log[0] == 1) x q1[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT7_log_raw = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT7_log = cT7_log_raw;\nif(syn_measT7 == 2) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 4) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 6) cT7_log = cT7_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT7_log = cT7_log ^ pf[0];\n\n//Logical X\nif(cT7_log[0] == 1) x q2[4];\nif(cT7_log[0] == 1) x q2[5];\nif(cT7_log[0] == 1) x q2[6];\n\nif(cT7_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT8[0];\nmeasure q3[1] -> cT8[1];\nmeasure q3[2] -> cT8[2];\nmeasure q3[3] -> cT8[3];\nmeasure q3[4] -> cT8[4];\nmeasure q3[5] -> cT8[5];\nmeasure q3[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT8_log_raw = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT8_log = cT8_log_raw;\nif(syn_measT8 == 2) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 4) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 6) cT8_log = cT8_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT8_log = cT8_log ^ pf[0];\n\n//Logical X\nif(cT8_log[0] == 1) x q1[4];\nif(cT8_log[0] == 1) x q1[5];\nif(cT8_log[0] == 1) x q1[6];\n\nif(cT8_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT9_log_raw = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT9_log = cT9_log_raw;\nif(syn_measT9 == 2) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 4) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 6) cT9_log = cT9_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT9_log = cT9_log ^ pf[0];\n\n//Logical X\nif(cT9_log[0] == 1) x q3[4];\nif(cT9_log[0] == 1) x q3[5];\nif(cT9_log[0] == 1) x q3[6];\n\nif(cT9_log[0] == 1) rz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT10[0];\nmeasure q3[1] -> cT10[1];\nmeasure q3[2] -> cT10[2];\nmeasure q3[3] -> cT10[3];\nmeasure q3[4] -> cT10[4];\nmeasure q3[5] -> cT10[5];\nmeasure q3[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT10_log_raw = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT10_log = cT10_log_raw;\nif(syn_measT10 == 2) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 4) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 6) cT10_log = cT10_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT10_log = cT10_log ^ pf[0];\n\n//Logical X\nif(cT10_log[0] == 1) x q1[4];\nif(cT10_log[0] == 1) x q1[5];\nif(cT10_log[0] == 1) x q1[6];\n\nif(cT10_log[0] == 1) rz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q0;\ncx q3[0], q0[0];\ncx q3[1], q0[1];\ncx q3[2], q0[2];\ncx q3[3], q0[3];\ncx q3[4], q0[4];\ncx q3[5], q0[5];\ncx q3[6], q0[6];\nbarrier q3, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT11[0];\nmeasure q0[1] -> cT11[1];\nmeasure q0[2] -> cT11[2];\nmeasure q0[3] -> cT11[3];\nmeasure q0[4] -> cT11[4];\nmeasure q0[5] -> cT11[5];\nmeasure q0[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT11_log_raw = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT11_log = cT11_log_raw;\nif(syn_measT11 == 2) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 4) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 6) cT11_log = cT11_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT11_log = cT11_log ^ pf[0];\n\n//Logical X\nif(cT11_log[0] == 1) x q3[4];\nif(cT11_log[0] == 1) x q3[5];\nif(cT11_log[0] == 1) x q3[6];\n\nif(cT11_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\nbarrier q3;\nbarrier q1;\nbarrier q2;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c0[0];\nmeasure q3[1] -> c0[1];\nmeasure q3[2] -> c0[2];\nmeasure q3[3] -> c0[3];\nmeasure q3[4] -> c0[4];\nmeasure q3[5] -> c0[5];\nmeasure q3[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> c2[0];\nmeasure q2[1] -> c2[1];\nmeasure q2[2] -> c2[2];\nmeasure q2[3] -> c2[3];\nmeasure q2[4] -> c2[4];\nmeasure q2[5] -> c2[5];\nmeasure q2[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];\nc[2] = c2_log[0];"}, "14": {"parameters": ["fourier", "100"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg init[4];\ncreg c0[7];\ncreg c1[7];\ncreg c2[7];\ncreg c0_log_raw[7];\ncreg c1_log_raw[7];\ncreg c2_log_raw[7];\ncreg c0_log[7];\ncreg c1_log[7];\ncreg c2_log[7];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\ncreg syn_meas2[3];\ncreg c[3];\ncreg c_mid[7];\ncreg c_mid_log_raw[1];\ncreg c_mid_log[1];\ncreg syn_meas_mid[3];\ncreg cT1[7];\ncreg cT2[7];\ncreg cT3[7];\ncreg cT4[7];\ncreg cT5[7];\ncreg cT6[7];\ncreg cT7[7];\ncreg cT8[7];\ncreg cT9[7];\ncreg cT10[7];\ncreg cT11[7];\ncreg cT12[7];\ncreg cT13[7];\ncreg cT1_log_raw[1];\ncreg cT2_log_raw[1];\ncreg cT3_log_raw[1];\ncreg cT4_log_raw[1];\ncreg cT5_log_raw[1];\ncreg cT6_log_raw[1];\ncreg cT7_log_raw[1];\ncreg cT8_log_raw[1];\ncreg cT9_log_raw[1];\ncreg cT10_log_raw[1];\ncreg cT11_log_raw[1];\ncreg cT12_log_raw[1];\ncreg cT13_log_raw[1];\ncreg cT1_log[1];\ncreg cT2_log[1];\ncreg cT3_log[1];\ncreg cT4_log[1];\ncreg cT5_log[1];\ncreg cT6_log[1];\ncreg cT7_log[1];\ncreg cT8_log[1];\ncreg cT9_log[1];\ncreg cT10_log[1];\ncreg cT11_log[1];\ncreg cT12_log[1];\ncreg cT13_log[1];\ncreg syn_measT1[3];\ncreg syn_measT2[3];\ncreg syn_measT3[3];\ncreg syn_measT4[3];\ncreg syn_measT5[3];\ncreg syn_measT6[3];\ncreg syn_measT7[3];\ncreg syn_measT8[3];\ncreg syn_measT9[3];\ncreg syn_measT10[3];\ncreg syn_measT11[3];\ncreg syn_measT12[3];\ncreg syn_measT13[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n// Logical H\nh q0;\n// Logical H\nh q2;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT12[0];\nmeasure q3[1] -> cT12[1];\nmeasure q3[2] -> cT12[2];\nmeasure q3[3] -> cT12[3];\nmeasure q3[4] -> cT12[4];\nmeasure q3[5] -> cT12[5];\nmeasure q3[6] -> cT12[6];\n\n// determine raw logical output\n// ============================\ncT12_log_raw = cT12[4] ^ cT12[5] ^ cT12[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT12[0] = cT12[0] ^ cT12[1] ^ cT12[2] ^ cT12[3];\nsyn_measT12[1] = cT12[1] ^ cT12[2] ^ cT12[4] ^ cT12[5];\nsyn_measT12[2] = cT12[2] ^ cT12[3] ^ cT12[5] ^ cT12[6];\n\n// XOR syndromes\nsyn_measT12 = syn_measT12 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT12_log = cT12_log_raw;\nif(syn_measT12 == 2) cT12_log = cT12_log ^ 1;\nif(syn_measT12 == 4) cT12_log = cT12_log ^ 1;\nif(syn_measT12 == 6) cT12_log = cT12_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT12_log = cT12_log ^ pf[0];\nif(cT12_log[0] == 1) rz(-pi/2) q0;\n\n//Logical X\nx q0[4];\nx q0[5];\nx q0[6];\n\n\n//Logical Z\nz q2[4];\nz q2[5];\nz q2[6];\n\n// Logical H\nh q2;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT1_log = cT1_log_raw;\nif(syn_measT1 == 2) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 4) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 6) cT1_log = cT1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT1_log = cT1_log ^ pf[0];\n\n//Logical X\nif(cT1_log[0] == 1) x q3[4];\nif(cT1_log[0] == 1) x q3[5];\nif(cT1_log[0] == 1) x q3[6];\n\nif(cT1_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q1[4];\nif(cT2_log[0] == 1) x q1[5];\nif(cT2_log[0] == 1) x q1[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q1[4];\nif(cT4_log[0] == 1) x q1[5];\nif(cT4_log[0] == 1) x q1[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c_mid[0];\nmeasure q3[1] -> c_mid[1];\nmeasure q3[2] -> c_mid[2];\nmeasure q3[3] -> c_mid[3];\nmeasure q3[4] -> c_mid[4];\nmeasure q3[5] -> c_mid[5];\nmeasure q3[6] -> c_mid[6];\n\n// determine raw logical output\n// ============================\nc_mid_log_raw = c_mid[4] ^ c_mid[5] ^ c_mid[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas_mid[0] = c_mid[0] ^ c_mid[1] ^ c_mid[2] ^ c_mid[3];\nsyn_meas_mid[1] = c_mid[1] ^ c_mid[2] ^ c_mid[4] ^ c_mid[5];\nsyn_meas_mid[2] = c_mid[2] ^ c_mid[3] ^ c_mid[5] ^ c_mid[6];\n\n// XOR syndromes\nsyn_meas_mid = syn_meas_mid ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_mid_log = c_mid_log_raw;\nif(syn_meas_mid == 2) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 4) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 6) c_mid_log = c_mid_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_mid_log = c_mid_log ^ pf[0];\n// Logical H\nif(c_mid_log[0] == 1) h q2;\n\n// Transversal Logical CX\nif(c_mid_log[0] == 1) barrier q0, q2;\nif(c_mid_log[0] == 1) cx q0[0], q2[0];\nif(c_mid_log[0] == 1) cx q0[1], q2[1];\nif(c_mid_log[0] == 1) cx q0[2], q2[2];\nif(c_mid_log[0] == 1) cx q0[3], q2[3];\nif(c_mid_log[0] == 1) cx q0[4], q2[4];\nif(c_mid_log[0] == 1) cx q0[5], q2[5];\nif(c_mid_log[0] == 1) cx q0[6], q2[6];\nif(c_mid_log[0] == 1) barrier q0, q2;\n\n// Logical H\nif(c_mid_log[0] == 1) h q2;\nreset q3;\n\nbarrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nreset q3;\nreset q1[0];\nbarrier q3, q1[0];\n\nh q3[0];\nh q3[4];\nh q3[6];\n\ncx q3[4],q3[5];\ncx q3[0],q3[1];\ncx q3[6],q3[3];\ncx q3[4],q3[2];\ncx q3[6],q3[5];\ncx q3[0],q3[3];\ncx q3[4],q3[1];\ncx q3[3], q3[2];\n\nbarrier q1[0],q3[1],q3[3],q3[5];\n//verification step\ncx q3[5],q1[0];\ncx q3[1],q1[0];\ncx q3[3],q1[0];\nmeasure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\n// Logical H\nh q3;\nrz(pi/2) q3;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q2;\ncx q1[0], q2[0];\ncx q1[1], q2[1];\ncx q1[2], q2[2];\ncx q1[3], q2[3];\ncx q1[4], q2[4];\ncx q1[5], q2[5];\ncx q1[6], q2[6];\nbarrier q1, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT6[0];\nmeasure q2[1] -> cT6[1];\nmeasure q2[2] -> cT6[2];\nmeasure q2[3] -> cT6[3];\nmeasure q2[4] -> cT6[4];\nmeasure q2[5] -> cT6[5];\nmeasure q2[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q1[4];\nif(cT6_log[0] == 1) x q1[5];\nif(cT6_log[0] == 1) x q1[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\nrz(-pi/2) q2;\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT7_log_raw = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT7_log = cT7_log_raw;\nif(syn_measT7 == 2) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 4) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 6) cT7_log = cT7_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT7_log = cT7_log ^ pf[0];\n\n//Logical X\nif(cT7_log[0] == 1) x q2[4];\nif(cT7_log[0] == 1) x q2[5];\nif(cT7_log[0] == 1) x q2[6];\n\nif(cT7_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT8[0];\nmeasure q3[1] -> cT8[1];\nmeasure q3[2] -> cT8[2];\nmeasure q3[3] -> cT8[3];\nmeasure q3[4] -> cT8[4];\nmeasure q3[5] -> cT8[5];\nmeasure q3[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT8_log_raw = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT8_log = cT8_log_raw;\nif(syn_measT8 == 2) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 4) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 6) cT8_log = cT8_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT8_log = cT8_log ^ pf[0];\n\n//Logical X\nif(cT8_log[0] == 1) x q1[4];\nif(cT8_log[0] == 1) x q1[5];\nif(cT8_log[0] == 1) x q1[6];\n\nif(cT8_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT9_log_raw = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT9_log = cT9_log_raw;\nif(syn_measT9 == 2) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 4) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 6) cT9_log = cT9_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT9_log = cT9_log ^ pf[0];\n\n//Logical X\nif(cT9_log[0] == 1) x q3[4];\nif(cT9_log[0] == 1) x q3[5];\nif(cT9_log[0] == 1) x q3[6];\n\nif(cT9_log[0] == 1) rz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT10[0];\nmeasure q3[1] -> cT10[1];\nmeasure q3[2] -> cT10[2];\nmeasure q3[3] -> cT10[3];\nmeasure q3[4] -> cT10[4];\nmeasure q3[5] -> cT10[5];\nmeasure q3[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT10_log_raw = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT10_log = cT10_log_raw;\nif(syn_measT10 == 2) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 4) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 6) cT10_log = cT10_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT10_log = cT10_log ^ pf[0];\n\n//Logical X\nif(cT10_log[0] == 1) x q1[4];\nif(cT10_log[0] == 1) x q1[5];\nif(cT10_log[0] == 1) x q1[6];\n\nif(cT10_log[0] == 1) rz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q0;\ncx q3[0], q0[0];\ncx q3[1], q0[1];\ncx q3[2], q0[2];\ncx q3[3], q0[3];\ncx q3[4], q0[4];\ncx q3[5], q0[5];\ncx q3[6], q0[6];\nbarrier q3, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT11[0];\nmeasure q0[1] -> cT11[1];\nmeasure q0[2] -> cT11[2];\nmeasure q0[3] -> cT11[3];\nmeasure q0[4] -> cT11[4];\nmeasure q0[5] -> cT11[5];\nmeasure q0[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT11_log_raw = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT11_log = cT11_log_raw;\nif(syn_measT11 == 2) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 4) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 6) cT11_log = cT11_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT11_log = cT11_log ^ pf[0];\n\n//Logical X\nif(cT11_log[0] == 1) x q3[4];\nif(cT11_log[0] == 1) x q3[5];\nif(cT11_log[0] == 1) x q3[6];\n\nif(cT11_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\nbarrier q3;\nbarrier q1;\nbarrier q2;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c0[0];\nmeasure q3[1] -> c0[1];\nmeasure q3[2] -> c0[2];\nmeasure q3[3] -> c0[3];\nmeasure q3[4] -> c0[4];\nmeasure q3[5] -> c0[5];\nmeasure q3[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> c2[0];\nmeasure q2[1] -> c2[1];\nmeasure q2[2] -> c2[2];\nmeasure q2[3] -> c2[3];\nmeasure q2[4] -> c2[4];\nmeasure q2[5] -> c2[5];\nmeasure q2[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];\nc[2] = c2_log[0];"}, "15": {"parameters": ["fourier", "000"], "qasm": "OPENQASM 2.0;\ninclude \"hqslib1.inc\";\n// Generated using: SLR 0.2.dev4 and qeclib 0.2.dev4\nqreg q0[7];\nqreg q1[7];\nqreg q2[7];\nqreg q3[7];\ncreg init[4];\ncreg c0[7];\ncreg c1[7];\ncreg c2[7];\ncreg c0_log_raw[7];\ncreg c1_log_raw[7];\ncreg c2_log_raw[7];\ncreg c0_log[7];\ncreg c1_log[7];\ncreg c2_log[7];\ncreg syn_meas0[3];\ncreg syn_meas1[3];\ncreg syn_meas2[3];\ncreg c[3];\ncreg c_mid[7];\ncreg c_mid_log_raw[1];\ncreg c_mid_log[1];\ncreg syn_meas_mid[3];\ncreg cT1[7];\ncreg cT2[7];\ncreg cT3[7];\ncreg cT4[7];\ncreg cT5[7];\ncreg cT6[7];\ncreg cT7[7];\ncreg cT8[7];\ncreg cT9[7];\ncreg cT10[7];\ncreg cT11[7];\ncreg cT12[7];\ncreg cT13[7];\ncreg cT1_log_raw[1];\ncreg cT2_log_raw[1];\ncreg cT3_log_raw[1];\ncreg cT4_log_raw[1];\ncreg cT5_log_raw[1];\ncreg cT6_log_raw[1];\ncreg cT7_log_raw[1];\ncreg cT8_log_raw[1];\ncreg cT9_log_raw[1];\ncreg cT10_log_raw[1];\ncreg cT11_log_raw[1];\ncreg cT12_log_raw[1];\ncreg cT13_log_raw[1];\ncreg cT1_log[1];\ncreg cT2_log[1];\ncreg cT3_log[1];\ncreg cT4_log[1];\ncreg cT5_log[1];\ncreg cT6_log[1];\ncreg cT7_log[1];\ncreg cT8_log[1];\ncreg cT9_log[1];\ncreg cT10_log[1];\ncreg cT11_log[1];\ncreg cT12_log[1];\ncreg cT13_log[1];\ncreg syn_measT1[3];\ncreg syn_measT2[3];\ncreg syn_measT3[3];\ncreg syn_measT4[3];\ncreg syn_measT5[3];\ncreg syn_measT6[3];\ncreg syn_measT7[3];\ncreg syn_measT8[3];\ncreg syn_measT9[3];\ncreg syn_measT10[3];\ncreg syn_measT11[3];\ncreg syn_measT12[3];\ncreg syn_measT13[3];\ncreg pf[2];\ncreg last_raw_syn_x[3];\ncreg last_raw_syn_z[3];\n\nbarrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nreset q0;\nreset q3[0];\nbarrier q0, q3[0];\n\nh q0[0];\nh q0[4];\nh q0[6];\n\ncx q0[4],q0[5];\ncx q0[0],q0[1];\ncx q0[6],q0[3];\ncx q0[4],q0[2];\ncx q0[6],q0[5];\ncx q0[0],q0[3];\ncx q0[4],q0[1];\ncx q0[3], q0[2];\n\nbarrier q3[0],q0[1],q0[3],q0[5];\n//verification step\ncx q0[5],q3[0];\ncx q0[1],q3[0];\ncx q0[3],q3[0];\nmeasure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\nif(init[0] == 1) barrier q0[0],q0[1],q0[2],q0[3],q0[4],q0[5],q0[6],q3[0];\nif(init[0] == 1) reset q0;\nif(init[0] == 1) reset q3[0];\nif(init[0] == 1) barrier q0, q3[0];\n\nif(init[0] == 1) h q0[0];\nif(init[0] == 1) h q0[4];\nif(init[0] == 1) h q0[6];\n\nif(init[0] == 1) cx q0[4],q0[5];\nif(init[0] == 1) cx q0[0],q0[1];\nif(init[0] == 1) cx q0[6],q0[3];\nif(init[0] == 1) cx q0[4],q0[2];\nif(init[0] == 1) cx q0[6],q0[5];\nif(init[0] == 1) cx q0[0],q0[3];\nif(init[0] == 1) cx q0[4],q0[1];\nif(init[0] == 1) cx q0[3], q0[2];\n\nif(init[0] == 1) barrier q3[0],q0[1],q0[3],q0[5];\n//verification step\nif(init[0] == 1) cx q0[5],q3[0];\nif(init[0] == 1) cx q0[1],q3[0];\nif(init[0] == 1) cx q0[3],q3[0];\nif(init[0] == 1) measure q3[0] -> init[0];\n\n\n\nbarrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nreset q1;\nreset q3[1];\nbarrier q1, q3[1];\n\nh q1[0];\nh q1[4];\nh q1[6];\n\ncx q1[4],q1[5];\ncx q1[0],q1[1];\ncx q1[6],q1[3];\ncx q1[4],q1[2];\ncx q1[6],q1[5];\ncx q1[0],q1[3];\ncx q1[4],q1[1];\ncx q1[3], q1[2];\n\nbarrier q3[1],q1[1],q1[3],q1[5];\n//verification step\ncx q1[5],q3[1];\ncx q1[1],q3[1];\ncx q1[3],q3[1];\nmeasure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\nif(init[1] == 1) barrier q1[0],q1[1],q1[2],q1[3],q1[4],q1[5],q1[6],q3[1];\nif(init[1] == 1) reset q1;\nif(init[1] == 1) reset q3[1];\nif(init[1] == 1) barrier q1, q3[1];\n\nif(init[1] == 1) h q1[0];\nif(init[1] == 1) h q1[4];\nif(init[1] == 1) h q1[6];\n\nif(init[1] == 1) cx q1[4],q1[5];\nif(init[1] == 1) cx q1[0],q1[1];\nif(init[1] == 1) cx q1[6],q1[3];\nif(init[1] == 1) cx q1[4],q1[2];\nif(init[1] == 1) cx q1[6],q1[5];\nif(init[1] == 1) cx q1[0],q1[3];\nif(init[1] == 1) cx q1[4],q1[1];\nif(init[1] == 1) cx q1[3], q1[2];\n\nif(init[1] == 1) barrier q3[1],q1[1],q1[3],q1[5];\n//verification step\nif(init[1] == 1) cx q1[5],q3[1];\nif(init[1] == 1) cx q1[1],q3[1];\nif(init[1] == 1) cx q1[3],q3[1];\nif(init[1] == 1) measure q3[1] -> init[1];\n\n\n\nbarrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nreset q2;\nreset q3[2];\nbarrier q2, q3[2];\n\nh q2[0];\nh q2[4];\nh q2[6];\n\ncx q2[4],q2[5];\ncx q2[0],q2[1];\ncx q2[6],q2[3];\ncx q2[4],q2[2];\ncx q2[6],q2[5];\ncx q2[0],q2[3];\ncx q2[4],q2[1];\ncx q2[3], q2[2];\n\nbarrier q3[2],q2[1],q2[3],q2[5];\n//verification step\ncx q2[5],q3[2];\ncx q2[1],q3[2];\ncx q2[3],q3[2];\nmeasure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\nif(init[2] == 1) barrier q2[0],q2[1],q2[2],q2[3],q2[4],q2[5],q2[6],q3[2];\nif(init[2] == 1) reset q2;\nif(init[2] == 1) reset q3[2];\nif(init[2] == 1) barrier q2, q3[2];\n\nif(init[2] == 1) h q2[0];\nif(init[2] == 1) h q2[4];\nif(init[2] == 1) h q2[6];\n\nif(init[2] == 1) cx q2[4],q2[5];\nif(init[2] == 1) cx q2[0],q2[1];\nif(init[2] == 1) cx q2[6],q2[3];\nif(init[2] == 1) cx q2[4],q2[2];\nif(init[2] == 1) cx q2[6],q2[5];\nif(init[2] == 1) cx q2[0],q2[3];\nif(init[2] == 1) cx q2[4],q2[1];\nif(init[2] == 1) cx q2[3], q2[2];\n\nif(init[2] == 1) barrier q3[2],q2[1],q2[3],q2[5];\n//verification step\nif(init[2] == 1) cx q2[5],q3[2];\nif(init[2] == 1) cx q2[1],q3[2];\nif(init[2] == 1) cx q2[3],q3[2];\nif(init[2] == 1) measure q3[2] -> init[2];\n\n\n// Logical H\nh q0;\n// Logical H\nh q2;\n// Logical H\nh q2;\n// Logical H\nh q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT1[0];\nmeasure q1[1] -> cT1[1];\nmeasure q1[2] -> cT1[2];\nmeasure q1[3] -> cT1[3];\nmeasure q1[4] -> cT1[4];\nmeasure q1[5] -> cT1[5];\nmeasure q1[6] -> cT1[6];\n\n// determine raw logical output\n// ============================\ncT1_log_raw = cT1[4] ^ cT1[5] ^ cT1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT1[0] = cT1[0] ^ cT1[1] ^ cT1[2] ^ cT1[3];\nsyn_measT1[1] = cT1[1] ^ cT1[2] ^ cT1[4] ^ cT1[5];\nsyn_measT1[2] = cT1[2] ^ cT1[3] ^ cT1[5] ^ cT1[6];\n\n// XOR syndromes\nsyn_measT1 = syn_measT1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT1_log = cT1_log_raw;\nif(syn_measT1 == 2) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 4) cT1_log = cT1_log ^ 1;\nif(syn_measT1 == 6) cT1_log = cT1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT1_log = cT1_log ^ pf[0];\n\n//Logical X\nif(cT1_log[0] == 1) x q3[4];\nif(cT1_log[0] == 1) x q3[5];\nif(cT1_log[0] == 1) x q3[6];\n\nif(cT1_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT2[0];\nmeasure q3[1] -> cT2[1];\nmeasure q3[2] -> cT2[2];\nmeasure q3[3] -> cT2[3];\nmeasure q3[4] -> cT2[4];\nmeasure q3[5] -> cT2[5];\nmeasure q3[6] -> cT2[6];\n\n// determine raw logical output\n// ============================\ncT2_log_raw = cT2[4] ^ cT2[5] ^ cT2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT2[0] = cT2[0] ^ cT2[1] ^ cT2[2] ^ cT2[3];\nsyn_measT2[1] = cT2[1] ^ cT2[2] ^ cT2[4] ^ cT2[5];\nsyn_measT2[2] = cT2[2] ^ cT2[3] ^ cT2[5] ^ cT2[6];\n\n// XOR syndromes\nsyn_measT2 = syn_measT2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT2_log = cT2_log_raw;\nif(syn_measT2 == 2) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 4) cT2_log = cT2_log ^ 1;\nif(syn_measT2 == 6) cT2_log = cT2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT2_log = cT2_log ^ pf[0];\n\n//Logical X\nif(cT2_log[0] == 1) x q1[4];\nif(cT2_log[0] == 1) x q1[5];\nif(cT2_log[0] == 1) x q1[6];\n\nif(cT2_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT3[0];\nmeasure q1[1] -> cT3[1];\nmeasure q1[2] -> cT3[2];\nmeasure q1[3] -> cT3[3];\nmeasure q1[4] -> cT3[4];\nmeasure q1[5] -> cT3[5];\nmeasure q1[6] -> cT3[6];\n\n// determine raw logical output\n// ============================\ncT3_log_raw = cT3[4] ^ cT3[5] ^ cT3[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT3[0] = cT3[0] ^ cT3[1] ^ cT3[2] ^ cT3[3];\nsyn_measT3[1] = cT3[1] ^ cT3[2] ^ cT3[4] ^ cT3[5];\nsyn_measT3[2] = cT3[2] ^ cT3[3] ^ cT3[5] ^ cT3[6];\n\n// XOR syndromes\nsyn_measT3 = syn_measT3 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT3_log = cT3_log_raw;\nif(syn_measT3 == 2) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 4) cT3_log = cT3_log ^ 1;\nif(syn_measT3 == 6) cT3_log = cT3_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT3_log = cT3_log ^ pf[0];\n\n//Logical X\nif(cT3_log[0] == 1) x q3[4];\nif(cT3_log[0] == 1) x q3[5];\nif(cT3_log[0] == 1) x q3[6];\n\nif(cT3_log[0] == 1) rz(-pi/2) q3;\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n\n// Transversal Logical CX\nbarrier q2, q3;\ncx q2[0], q3[0];\ncx q2[1], q3[1];\ncx q2[2], q3[2];\ncx q2[3], q3[3];\ncx q2[4], q3[4];\ncx q2[5], q3[5];\ncx q2[6], q3[6];\nbarrier q2, q3;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT4[0];\nmeasure q3[1] -> cT4[1];\nmeasure q3[2] -> cT4[2];\nmeasure q3[3] -> cT4[3];\nmeasure q3[4] -> cT4[4];\nmeasure q3[5] -> cT4[5];\nmeasure q3[6] -> cT4[6];\n\n// determine raw logical output\n// ============================\ncT4_log_raw = cT4[4] ^ cT4[5] ^ cT4[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT4[0] = cT4[0] ^ cT4[1] ^ cT4[2] ^ cT4[3];\nsyn_measT4[1] = cT4[1] ^ cT4[2] ^ cT4[4] ^ cT4[5];\nsyn_measT4[2] = cT4[2] ^ cT4[3] ^ cT4[5] ^ cT4[6];\n\n// XOR syndromes\nsyn_measT4 = syn_measT4 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT4_log = cT4_log_raw;\nif(syn_measT4 == 2) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 4) cT4_log = cT4_log ^ 1;\nif(syn_measT4 == 6) cT4_log = cT4_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT4_log = cT4_log ^ pf[0];\n\n//Logical X\nif(cT4_log[0] == 1) x q1[4];\nif(cT4_log[0] == 1) x q1[5];\nif(cT4_log[0] == 1) x q1[6];\n\nif(cT4_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\nrz(-pi/2) q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT5[0];\nmeasure q1[1] -> cT5[1];\nmeasure q1[2] -> cT5[2];\nmeasure q1[3] -> cT5[3];\nmeasure q1[4] -> cT5[4];\nmeasure q1[5] -> cT5[5];\nmeasure q1[6] -> cT5[6];\n\n// determine raw logical output\n// ============================\ncT5_log_raw = cT5[4] ^ cT5[5] ^ cT5[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT5[0] = cT5[0] ^ cT5[1] ^ cT5[2] ^ cT5[3];\nsyn_measT5[1] = cT5[1] ^ cT5[2] ^ cT5[4] ^ cT5[5];\nsyn_measT5[2] = cT5[2] ^ cT5[3] ^ cT5[5] ^ cT5[6];\n\n// XOR syndromes\nsyn_measT5 = syn_measT5 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT5_log = cT5_log_raw;\nif(syn_measT5 == 2) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 4) cT5_log = cT5_log ^ 1;\nif(syn_measT5 == 6) cT5_log = cT5_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT5_log = cT5_log ^ pf[0];\n\n//Logical X\nif(cT5_log[0] == 1) x q3[4];\nif(cT5_log[0] == 1) x q3[5];\nif(cT5_log[0] == 1) x q3[6];\n\nif(cT5_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c_mid[0];\nmeasure q3[1] -> c_mid[1];\nmeasure q3[2] -> c_mid[2];\nmeasure q3[3] -> c_mid[3];\nmeasure q3[4] -> c_mid[4];\nmeasure q3[5] -> c_mid[5];\nmeasure q3[6] -> c_mid[6];\n\n// determine raw logical output\n// ============================\nc_mid_log_raw = c_mid[4] ^ c_mid[5] ^ c_mid[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas_mid[0] = c_mid[0] ^ c_mid[1] ^ c_mid[2] ^ c_mid[3];\nsyn_meas_mid[1] = c_mid[1] ^ c_mid[2] ^ c_mid[4] ^ c_mid[5];\nsyn_meas_mid[2] = c_mid[2] ^ c_mid[3] ^ c_mid[5] ^ c_mid[6];\n\n// XOR syndromes\nsyn_meas_mid = syn_meas_mid ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc_mid_log = c_mid_log_raw;\nif(syn_meas_mid == 2) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 4) c_mid_log = c_mid_log ^ 1;\nif(syn_meas_mid == 6) c_mid_log = c_mid_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc_mid_log = c_mid_log ^ pf[0];\n// Logical H\nif(c_mid_log[0] == 1) h q2;\n\n// Transversal Logical CX\nif(c_mid_log[0] == 1) barrier q0, q2;\nif(c_mid_log[0] == 1) cx q0[0], q2[0];\nif(c_mid_log[0] == 1) cx q0[1], q2[1];\nif(c_mid_log[0] == 1) cx q0[2], q2[2];\nif(c_mid_log[0] == 1) cx q0[3], q2[3];\nif(c_mid_log[0] == 1) cx q0[4], q2[4];\nif(c_mid_log[0] == 1) cx q0[5], q2[5];\nif(c_mid_log[0] == 1) cx q0[6], q2[6];\nif(c_mid_log[0] == 1) barrier q0, q2;\n\n// Logical H\nif(c_mid_log[0] == 1) h q2;\nreset q3;\n\nbarrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nreset q3;\nreset q1[0];\nbarrier q3, q1[0];\n\nh q3[0];\nh q3[4];\nh q3[6];\n\ncx q3[4],q3[5];\ncx q3[0],q3[1];\ncx q3[6],q3[3];\ncx q3[4],q3[2];\ncx q3[6],q3[5];\ncx q3[0],q3[3];\ncx q3[4],q3[1];\ncx q3[3], q3[2];\n\nbarrier q1[0],q3[1],q3[3],q3[5];\n//verification step\ncx q3[5],q1[0];\ncx q3[1],q1[0];\ncx q3[3],q1[0];\nmeasure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\nif(init[3] == 1) barrier q3[0],q3[1],q3[2],q3[3],q3[4],q3[5],q3[6],q1[0];\nif(init[3] == 1) reset q3;\nif(init[3] == 1) reset q1[0];\nif(init[3] == 1) barrier q3, q1[0];\n\nif(init[3] == 1) h q3[0];\nif(init[3] == 1) h q3[4];\nif(init[3] == 1) h q3[6];\n\nif(init[3] == 1) cx q3[4],q3[5];\nif(init[3] == 1) cx q3[0],q3[1];\nif(init[3] == 1) cx q3[6],q3[3];\nif(init[3] == 1) cx q3[4],q3[2];\nif(init[3] == 1) cx q3[6],q3[5];\nif(init[3] == 1) cx q3[0],q3[3];\nif(init[3] == 1) cx q3[4],q3[1];\nif(init[3] == 1) cx q3[3], q3[2];\n\nif(init[3] == 1) barrier q1[0],q3[1],q3[3],q3[5];\n//verification step\nif(init[3] == 1) cx q3[5],q1[0];\nif(init[3] == 1) cx q3[1],q1[0];\nif(init[3] == 1) cx q3[3],q1[0];\nif(init[3] == 1) measure q1[0] -> init[3];\n\n\n// Logical H\nh q3;\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n// Transversal Logical CX\nbarrier q1, q2;\ncx q1[0], q2[0];\ncx q1[1], q2[1];\ncx q1[2], q2[2];\ncx q1[3], q2[3];\ncx q1[4], q2[4];\ncx q1[5], q2[5];\ncx q1[6], q2[6];\nbarrier q1, q2;\n\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> cT6[0];\nmeasure q2[1] -> cT6[1];\nmeasure q2[2] -> cT6[2];\nmeasure q2[3] -> cT6[3];\nmeasure q2[4] -> cT6[4];\nmeasure q2[5] -> cT6[5];\nmeasure q2[6] -> cT6[6];\n\n// determine raw logical output\n// ============================\ncT6_log_raw = cT6[4] ^ cT6[5] ^ cT6[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT6[0] = cT6[0] ^ cT6[1] ^ cT6[2] ^ cT6[3];\nsyn_measT6[1] = cT6[1] ^ cT6[2] ^ cT6[4] ^ cT6[5];\nsyn_measT6[2] = cT6[2] ^ cT6[3] ^ cT6[5] ^ cT6[6];\n\n// XOR syndromes\nsyn_measT6 = syn_measT6 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT6_log = cT6_log_raw;\nif(syn_measT6 == 2) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 4) cT6_log = cT6_log ^ 1;\nif(syn_measT6 == 6) cT6_log = cT6_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT6_log = cT6_log ^ pf[0];\n\n//Logical X\nif(cT6_log[0] == 1) x q1[4];\nif(cT6_log[0] == 1) x q1[5];\nif(cT6_log[0] == 1) x q1[6];\n\nif(cT6_log[0] == 1) rz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q2[6];\nh q2[6];\nrz(pi/4) q2[6];\n\n// Encoding circuit\n// ---------------\nreset q2[0];\nreset q2[1];\nreset q2[2];\nreset q2[3];\nreset q2[4];\nreset q2[5];\n\n// q[6] is the input qubit\n\ncx q2[6],q2[5];\n\nh q2[1];\ncx q2[1], q2[0];\n\nh q2[2];\ncx q2[2], q2[4];\n\n// ---------------\nh q2[3];\ncx q2[3], q2[5];\ncx q2[2], q2[0];\ncx q2[6], q2[4];\n\n// ---------------\ncx q2[2], q2[6];\ncx q2[3], q2[4];\ncx q2[1], q2[5];\n\n// ---------------\ncx q2[1], q2[6];\ncx q2[3], q2[0];\n\n\n// Transversal Logical CX\nbarrier q2, q1;\ncx q2[0], q1[0];\ncx q2[1], q1[1];\ncx q2[2], q1[2];\ncx q2[3], q1[3];\ncx q2[4], q1[4];\ncx q2[5], q1[5];\ncx q2[6], q1[6];\nbarrier q2, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT7[0];\nmeasure q1[1] -> cT7[1];\nmeasure q1[2] -> cT7[2];\nmeasure q1[3] -> cT7[3];\nmeasure q1[4] -> cT7[4];\nmeasure q1[5] -> cT7[5];\nmeasure q1[6] -> cT7[6];\n\n// determine raw logical output\n// ============================\ncT7_log_raw = cT7[4] ^ cT7[5] ^ cT7[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT7[0] = cT7[0] ^ cT7[1] ^ cT7[2] ^ cT7[3];\nsyn_measT7[1] = cT7[1] ^ cT7[2] ^ cT7[4] ^ cT7[5];\nsyn_measT7[2] = cT7[2] ^ cT7[3] ^ cT7[5] ^ cT7[6];\n\n// XOR syndromes\nsyn_measT7 = syn_measT7 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT7_log = cT7_log_raw;\nif(syn_measT7 == 2) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 4) cT7_log = cT7_log ^ 1;\nif(syn_measT7 == 6) cT7_log = cT7_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT7_log = cT7_log ^ pf[0];\n\n//Logical X\nif(cT7_log[0] == 1) x q2[4];\nif(cT7_log[0] == 1) x q2[5];\nif(cT7_log[0] == 1) x q2[6];\n\nif(cT7_log[0] == 1) rz(-pi/2) q2;\n\n//Logical X\nx q2[4];\nx q2[5];\nx q2[6];\n\n\n// Transversal Logical CX\nbarrier q3, q2;\ncx q3[0], q2[0];\ncx q3[1], q2[1];\ncx q3[2], q2[2];\ncx q3[3], q2[3];\ncx q3[4], q2[4];\ncx q3[5], q2[5];\ncx q3[6], q2[6];\nbarrier q3, q2;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT8[0];\nmeasure q3[1] -> cT8[1];\nmeasure q3[2] -> cT8[2];\nmeasure q3[3] -> cT8[3];\nmeasure q3[4] -> cT8[4];\nmeasure q3[5] -> cT8[5];\nmeasure q3[6] -> cT8[6];\n\n// determine raw logical output\n// ============================\ncT8_log_raw = cT8[4] ^ cT8[5] ^ cT8[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT8[0] = cT8[0] ^ cT8[1] ^ cT8[2] ^ cT8[3];\nsyn_measT8[1] = cT8[1] ^ cT8[2] ^ cT8[4] ^ cT8[5];\nsyn_measT8[2] = cT8[2] ^ cT8[3] ^ cT8[5] ^ cT8[6];\n\n// XOR syndromes\nsyn_measT8 = syn_measT8 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT8_log = cT8_log_raw;\nif(syn_measT8 == 2) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 4) cT8_log = cT8_log ^ 1;\nif(syn_measT8 == 6) cT8_log = cT8_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT8_log = cT8_log ^ pf[0];\n\n//Logical X\nif(cT8_log[0] == 1) x q1[4];\nif(cT8_log[0] == 1) x q1[5];\nif(cT8_log[0] == 1) x q1[6];\n\nif(cT8_log[0] == 1) rz(-pi/2) q1;\n// Logical H\nh q1;\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\nrz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q3, q1;\ncx q3[0], q1[0];\ncx q3[1], q1[1];\ncx q3[2], q1[2];\ncx q3[3], q1[3];\ncx q3[4], q1[4];\ncx q3[5], q1[5];\ncx q3[6], q1[6];\nbarrier q3, q1;\n\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> cT9[0];\nmeasure q1[1] -> cT9[1];\nmeasure q1[2] -> cT9[2];\nmeasure q1[3] -> cT9[3];\nmeasure q1[4] -> cT9[4];\nmeasure q1[5] -> cT9[5];\nmeasure q1[6] -> cT9[6];\n\n// determine raw logical output\n// ============================\ncT9_log_raw = cT9[4] ^ cT9[5] ^ cT9[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT9[0] = cT9[0] ^ cT9[1] ^ cT9[2] ^ cT9[3];\nsyn_measT9[1] = cT9[1] ^ cT9[2] ^ cT9[4] ^ cT9[5];\nsyn_measT9[2] = cT9[2] ^ cT9[3] ^ cT9[5] ^ cT9[6];\n\n// XOR syndromes\nsyn_measT9 = syn_measT9 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT9_log = cT9_log_raw;\nif(syn_measT9 == 2) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 4) cT9_log = cT9_log ^ 1;\nif(syn_measT9 == 6) cT9_log = cT9_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT9_log = cT9_log ^ pf[0];\n\n//Logical X\nif(cT9_log[0] == 1) x q3[4];\nif(cT9_log[0] == 1) x q3[5];\nif(cT9_log[0] == 1) x q3[6];\n\nif(cT9_log[0] == 1) rz(-pi/2) q3;\n\n// Transversal Logical CX\nbarrier q0, q3;\ncx q0[0], q3[0];\ncx q0[1], q3[1];\ncx q0[2], q3[2];\ncx q0[3], q3[3];\ncx q0[4], q3[4];\ncx q0[5], q3[5];\ncx q0[6], q3[6];\nbarrier q0, q3;\n\n\n//Logical X\nx q3[4];\nx q3[5];\nx q3[6];\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q1[6];\nh q1[6];\nrz(pi/4) q1[6];\n\n// Encoding circuit\n// ---------------\nreset q1[0];\nreset q1[1];\nreset q1[2];\nreset q1[3];\nreset q1[4];\nreset q1[5];\n\n// q[6] is the input qubit\n\ncx q1[6],q1[5];\n\nh q1[1];\ncx q1[1], q1[0];\n\nh q1[2];\ncx q1[2], q1[4];\n\n// ---------------\nh q1[3];\ncx q1[3], q1[5];\ncx q1[2], q1[0];\ncx q1[6], q1[4];\n\n// ---------------\ncx q1[2], q1[6];\ncx q1[3], q1[4];\ncx q1[1], q1[5];\n\n// ---------------\ncx q1[1], q1[6];\ncx q1[3], q1[0];\n\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\nrz(-pi/2) q1;\n\n// Transversal Logical CX\nbarrier q1, q3;\ncx q1[0], q3[0];\ncx q1[1], q3[1];\ncx q1[2], q3[2];\ncx q1[3], q3[3];\ncx q1[4], q3[4];\ncx q1[5], q3[5];\ncx q1[6], q3[6];\nbarrier q1, q3;\n\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> cT10[0];\nmeasure q3[1] -> cT10[1];\nmeasure q3[2] -> cT10[2];\nmeasure q3[3] -> cT10[3];\nmeasure q3[4] -> cT10[4];\nmeasure q3[5] -> cT10[5];\nmeasure q3[6] -> cT10[6];\n\n// determine raw logical output\n// ============================\ncT10_log_raw = cT10[4] ^ cT10[5] ^ cT10[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT10[0] = cT10[0] ^ cT10[1] ^ cT10[2] ^ cT10[3];\nsyn_measT10[1] = cT10[1] ^ cT10[2] ^ cT10[4] ^ cT10[5];\nsyn_measT10[2] = cT10[2] ^ cT10[3] ^ cT10[5] ^ cT10[6];\n\n// XOR syndromes\nsyn_measT10 = syn_measT10 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT10_log = cT10_log_raw;\nif(syn_measT10 == 2) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 4) cT10_log = cT10_log ^ 1;\nif(syn_measT10 == 6) cT10_log = cT10_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT10_log = cT10_log ^ pf[0];\n\n//Logical X\nif(cT10_log[0] == 1) x q1[4];\nif(cT10_log[0] == 1) x q1[5];\nif(cT10_log[0] == 1) x q1[6];\n\nif(cT10_log[0] == 1) rz(-pi/2) q1;\n\n//Logical X\nx q1[4];\nx q1[5];\nx q1[6];\n\n\n// Transversal Logical CX\nbarrier q0, q1;\ncx q0[0], q1[0];\ncx q0[1], q1[1];\ncx q0[2], q1[2];\ncx q0[3], q1[3];\ncx q0[4], q1[4];\ncx q0[5], q1[5];\ncx q0[6], q1[6];\nbarrier q0, q1;\n\n// Initialize logical |T> = T|+>\n// =============================\nreset q3[6];\nh q3[6];\nrz(pi/4) q3[6];\n\n// Encoding circuit\n// ---------------\nreset q3[0];\nreset q3[1];\nreset q3[2];\nreset q3[3];\nreset q3[4];\nreset q3[5];\n\n// q[6] is the input qubit\n\ncx q3[6],q3[5];\n\nh q3[1];\ncx q3[1], q3[0];\n\nh q3[2];\ncx q3[2], q3[4];\n\n// ---------------\nh q3[3];\ncx q3[3], q3[5];\ncx q3[2], q3[0];\ncx q3[6], q3[4];\n\n// ---------------\ncx q3[2], q3[6];\ncx q3[3], q3[4];\ncx q3[1], q3[5];\n\n// ---------------\ncx q3[1], q3[6];\ncx q3[3], q3[0];\n\n\n// Transversal Logical CX\nbarrier q3, q0;\ncx q3[0], q0[0];\ncx q3[1], q0[1];\ncx q3[2], q0[2];\ncx q3[3], q0[3];\ncx q3[4], q0[4];\ncx q3[5], q0[5];\ncx q3[6], q0[6];\nbarrier q3, q0;\n\n// Destructive logical Z measurement\n\nbarrier q0;\n\nmeasure q0[0] -> cT11[0];\nmeasure q0[1] -> cT11[1];\nmeasure q0[2] -> cT11[2];\nmeasure q0[3] -> cT11[3];\nmeasure q0[4] -> cT11[4];\nmeasure q0[5] -> cT11[5];\nmeasure q0[6] -> cT11[6];\n\n// determine raw logical output\n// ============================\ncT11_log_raw = cT11[4] ^ cT11[5] ^ cT11[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_measT11[0] = cT11[0] ^ cT11[1] ^ cT11[2] ^ cT11[3];\nsyn_measT11[1] = cT11[1] ^ cT11[2] ^ cT11[4] ^ cT11[5];\nsyn_measT11[2] = cT11[2] ^ cT11[3] ^ cT11[5] ^ cT11[6];\n\n// XOR syndromes\nsyn_measT11 = syn_measT11 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\ncT11_log = cT11_log_raw;\nif(syn_measT11 == 2) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 4) cT11_log = cT11_log ^ 1;\nif(syn_measT11 == 6) cT11_log = cT11_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\ncT11_log = cT11_log ^ pf[0];\n\n//Logical X\nif(cT11_log[0] == 1) x q3[4];\nif(cT11_log[0] == 1) x q3[5];\nif(cT11_log[0] == 1) x q3[6];\n\nif(cT11_log[0] == 1) rz(-pi/2) q3;\n// Logical H\nh q3;\nbarrier q3;\nbarrier q1;\nbarrier q2;\n// Destructive logical Z measurement\n\nbarrier q3;\n\nmeasure q3[0] -> c0[0];\nmeasure q3[1] -> c0[1];\nmeasure q3[2] -> c0[2];\nmeasure q3[3] -> c0[3];\nmeasure q3[4] -> c0[4];\nmeasure q3[5] -> c0[5];\nmeasure q3[6] -> c0[6];\n\n// determine raw logical output\n// ============================\nc0_log_raw = c0[4] ^ c0[5] ^ c0[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas0[0] = c0[0] ^ c0[1] ^ c0[2] ^ c0[3];\nsyn_meas0[1] = c0[1] ^ c0[2] ^ c0[4] ^ c0[5];\nsyn_meas0[2] = c0[2] ^ c0[3] ^ c0[5] ^ c0[6];\n\n// XOR syndromes\nsyn_meas0 = syn_meas0 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc0_log = c0_log_raw;\nif(syn_meas0 == 2) c0_log = c0_log ^ 1;\nif(syn_meas0 == 4) c0_log = c0_log ^ 1;\nif(syn_meas0 == 6) c0_log = c0_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc0_log = c0_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q1;\n\nmeasure q1[0] -> c1[0];\nmeasure q1[1] -> c1[1];\nmeasure q1[2] -> c1[2];\nmeasure q1[3] -> c1[3];\nmeasure q1[4] -> c1[4];\nmeasure q1[5] -> c1[5];\nmeasure q1[6] -> c1[6];\n\n// determine raw logical output\n// ============================\nc1_log_raw = c1[4] ^ c1[5] ^ c1[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas1[0] = c1[0] ^ c1[1] ^ c1[2] ^ c1[3];\nsyn_meas1[1] = c1[1] ^ c1[2] ^ c1[4] ^ c1[5];\nsyn_meas1[2] = c1[2] ^ c1[3] ^ c1[5] ^ c1[6];\n\n// XOR syndromes\nsyn_meas1 = syn_meas1 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc1_log = c1_log_raw;\nif(syn_meas1 == 2) c1_log = c1_log ^ 1;\nif(syn_meas1 == 4) c1_log = c1_log ^ 1;\nif(syn_meas1 == 6) c1_log = c1_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc1_log = c1_log ^ pf[0];\n// Destructive logical Z measurement\n\nbarrier q2;\n\nmeasure q2[0] -> c2[0];\nmeasure q2[1] -> c2[1];\nmeasure q2[2] -> c2[2];\nmeasure q2[3] -> c2[3];\nmeasure q2[4] -> c2[4];\nmeasure q2[5] -> c2[5];\nmeasure q2[6] -> c2[6];\n\n// determine raw logical output\n// ============================\nc2_log_raw = c2[4] ^ c2[5] ^ c2[6];\n\n\n\n// =================== //\n// PROCESS MEASUREMENT //\n// =================== //\n\n// Determine correction to get logical output\n// ==========================================\nsyn_meas2[0] = c2[0] ^ c2[1] ^ c2[2] ^ c2[3];\nsyn_meas2[1] = c2[1] ^ c2[2] ^ c2[4] ^ c2[5];\nsyn_meas2[2] = c2[2] ^ c2[3] ^ c2[5] ^ c2[6];\n\n// XOR syndromes\nsyn_meas2 = syn_meas2 ^ last_raw_syn_z;\n\n// Correct logical output based on measured out syndromes\nc2_log = c2_log_raw;\nif(syn_meas2 == 2) c2_log = c2_log ^ 1;\nif(syn_meas2 == 4) c2_log = c2_log ^ 1;\nif(syn_meas2 == 6) c2_log = c2_log ^ 1;\n\n// Apply Pauli frame update (flip the logical output)\n// Update for logical Z out\nc2_log = c2_log ^ pf[0];\nc[0] = c0_log[0];\nc[1] = c1_log[0];\nc[2] = c2_log[0];"}}